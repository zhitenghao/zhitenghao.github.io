<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="C++初级, 学习,工作和生活">
    <meta name="description" content="记录生活,分享爱">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C++初级 | perfect</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="perfect" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">perfect</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">perfect</div>
        <div class="logo-desc">
            
            记录生活,分享爱
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C++初级</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                <span class="chip bg-color">后端</span>
                            </a>
                        
                            <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
                                <span class="chip bg-color">编程语言</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="post-category">
                                编程语言
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-05-05
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    2.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    10 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="C-第一阶段"><a href="#C-第一阶段" class="headerlink" title="C++第一阶段"></a>C++第一阶段</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1et411b73Z?p=7&spm_id_from=333.880.my_history.page.click">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a></li>
<li>学堂在线：清华大学，郑莉C++基础+进阶</li>
</ol>
<h2 id="第一章-导学"><a href="#第一章-导学" class="headerlink" title="第一章 导学"></a>第一章 导学</h2><h3 id="1-1-关于C"><a href="#1-1-关于C" class="headerlink" title="1.1 关于C++"></a>1.1 关于C++</h3><ol>
<li>从C语言发展而来，兼容C，支持面向对象的方法，支持泛型程序设计方法</li>
<li>C++11标准，包含了核心语言的新机能，扩展了C++标准库</li>
<li>最新的是C++14</li>
<li>函数的参数就是供函数计算使用的数据</li>
<li>函数的return语句就是返回函数的运算结果</li>
</ol>
<h3 id="1-2-计算机系统简介"><a href="#1-2-计算机系统简介" class="headerlink" title="1.2 计算机系统简介"></a>1.2 计算机系统简介</h3><ol>
<li><p>计算机的工作需要人来指挥</p>
</li>
<li><p>计算机能识别的是机器语言，机器语言指令是由0和1编码的，例如加法指令：0001</p>
</li>
<li><p>计算机的指令系统：机器硬件能够识别的语言（机器语言）的集合。它是软件和硬件的主要界面</p>
</li>
<li><p>计算机软件：应用软件、系统软件（操作系统，管理计算机的软硬件资源、管理任务等）、中间件（提供系统软件和应用软件之间链接的软件）</p>
</li>
<li><p>软件 = 程序 + 文档</p>
</li>
<li><p>程序是指令的序列 和 解决问题的方法和数据</p>
</li>
</ol>
<h3 id="1-3-计算机语言的和程序设计方法的发展"><a href="#1-3-计算机语言的和程序设计方法的发展" class="headerlink" title="1.3 计算机语言的和程序设计方法的发展"></a>1.3 计算机语言的和程序设计方法的发展</h3><ol>
<li>机器语言：由二进制代码构成，可以被硬件识别并执行</li>
<li>汇编语言：将机器指令映射为一些助记符，抽象层次低，需要考虑机器细节</li>
<li>高级语言：接近人类语言，屏蔽了机器的底层细节。</li>
<li>面向对象的高级语言：把客观现实中的事务看作对象（属性和行为）。对象之间通过消息传送的方式进行沟通，程序中也可以这样。支持分类和抽象。</li>
</ol>
<p><strong>程序设计方法的发展历程：</strong></p>
<ol>
<li>面向过程的程序设计方法：解决问题的步骤，主要设计求解问题，不利于做大型复杂的软件。</li>
<li>面向对象的程序设计方法：面向对象的高级语言支持，一个系统由对象构成，对象之间通过消息进行通信。</li>
</ol>
<h3 id="1-4-面向对象的基本概念"><a href="#1-4-面向对象的基本概念" class="headerlink" title="1.4 面向对象的基本概念"></a>1.4 面向对象的基本概念</h3><p>对象</p>
<p>类：抽象</p>
<p>封装</p>
<p>继承：意义在于软件复用，扩展形成新的类</p>
<p>多态：同样的消息作用在不同的对象上产生不同的影响</p>
<h3 id="1-5-程序的开发过程"><a href="#1-5-程序的开发过程" class="headerlink" title="1.5 程序的开发过程"></a>1.5 程序的开发过程</h3><ol>
<li>高级语言程序（源程序）要进行翻译成为机器语言（目标程序，二进制指令）才能被计算机识别执行</li>
<li>程序库，已经翻译成了二进制代码模块</li>
<li>可执行程序：连接目标程序以及程序库中的文件生成一个可执行的文件（.exe）</li>
<li><strong>汇编程序：</strong>把汇编语言翻译成机器语言。<strong>编译程序：</strong>将高级语言源程序翻译成目标程序。<strong>解释程序：</strong>将高级语言源程序翻译成机器指令，是边翻译边执行，执行效率低，翻译一条执行一条，每次运行都要如此。Java语言就是半编译半解释，通过Java虚拟机可以实现Java跨平台。</li>
<li>算法与数据结构设计</li>
<li>源程序编辑</li>
<li>编译程序：进行语法检查</li>
<li>连接：连接目标程序以及程序库中的文件生成一个可执行的文件（.exe）。</li>
<li>测试</li>
<li>调试</li>
</ol>
<h3 id="1-6-计算机中的信息与存储单位"><a href="#1-6-计算机中的信息与存储单位" class="headerlink" title="1.6 计算机中的信息与存储单位"></a>1.6 计算机中的信息与存储单位</h3><ol>
<li>计算机的基本功能：都是基于算术运算和逻辑运算</li>
<li>计算机中的信息：控制信息（指挥计算机操作），数据信息（数值信息（整数和实数）、非数值信息）</li>
<li>信息的存储单位：位（bit，b）：数据的最小单位</li>
<li>字节（byte， B）</li>
<li>千字节：KB</li>
<li>兆字节：M</li>
<li>吉字节：G</li>
</ol>
<h3 id="1-7-计算机的数字系统"><a href="#1-7-计算机的数字系统" class="headerlink" title="1.7 计算机的数字系统"></a>1.7 计算机的数字系统</h3><ol>
<li><p>二进制系统：0和1，表示两种状态</p>
</li>
<li><p>二进制、八进制（三个二进制位构成一个八进制位）、十进制、十六进制（可以表示内存地址，例如：0xFFFF，四个二进制位构成一个十六进制位）</p>
</li>
<li><p>不能直接在高级语言中使用二进制数据</p>
</li>
<li><p>进制转换</p>
</li>
</ol>
<p>数据的编码表示</p>
<ol>
<li>原码：0表示正，1表示负，0的表示不唯一，进行四则运算是符号位需要单独处理，运算规则复杂</li>
<li>补码：0的表示唯一，符号位可以直接参加运算，减法运算可以转换位加法运算，</li>
<li>模数：20 % 12 = 8，12就是模数。n位二进制整数的模数为2^n^，n为小数的模数为2。</li>
<li>补数：一个数减去另一个数（加一个负数）等于第一个数加第二个数的补数。例如：8 + (-2) = 8 + 10(mod 12) = 6</li>
<li>补码的计算规则：借助中间码（反码），补码 = 原码的反码 + 1。</li>
<li>反码：在原码的基础上，保持符号位不变，其他位取反。</li>
<li>正数的原码、反码、补码是一样的</li>
<li>运算结果溢出：负数之和得到正数或正数之和得到负数，结果不正确，也就是结果溢出。</li>
<li>小数的表述：定点表示（已过时）和浮点表示（常用）。</li>
<li>浮点表示：N = M * 2 ^ E。</li>
<li>E：2的幂次，称数N的阶码，反映了该浮点数所表示的数据范围。</li>
<li>M：N的尾数：其位数反映了数据的精度。</li>
<li>字符在计算机中通过编码表示。ASCLL码、汉字编码（国标）。</li>
</ol>
<h3 id="1-8-C-开发工具"><a href="#1-8-C-开发工具" class="headerlink" title="1.8 C++开发工具"></a>1.8 C++开发工具</h3><ol>
<li>visual studio 2022</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30815237/article/details/87452311">(11条消息) VS如何在一个项目中添加多个包含main函数的源文件并分别调试运行_菜鸟知识搬运工的博客-CSDN博客_vs一个项目添加多个源文件</a></li>
</ol>
<h2 id="第二章-C-简单程序设计"><a href="#第二章-C-简单程序设计" class="headerlink" title="第二章 C++简单程序设计"></a>第二章 C++简单程序设计</h2><h3 id="2-1-程序实例："><a href="#2-1-程序实例：" class="headerlink" title="2.1 程序实例："></a>2.1 程序实例：</h3><ol>
<li><p>#include <iostream>  给出了预定义好的输入输出的功能的声明</p>
</li>
<li><p>#include 编译预处理命令，在编译器开始语法检查，开始编译程序之前，首先要按照include指令到指定的目录下，去找到iostream文件，把该文件的全部命令复制到include指定的位置，iostream类的对象cin&gt;&gt;操作，可以从标准输入设备（通常是键盘）读入数据</p>
</li>
<li><p>using namespace std；命名空间可以避免命名冲突，std 是命名空间的名字</p>
</li>
<li><p>标识符只能由数字、字母、下划线组成，第一个字符不能是数字，且区分大小写</p>
</li>
</ol>
<h3 id="2-2-C-的基本数据类型"><a href="#2-2-C-的基本数据类型" class="headerlink" title="2.2 C++ 的基本数据类型"></a>2.2 C++ 的基本数据类型</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ol>
<li>程序运行过程中，数据不可变</li>
<li>符号常量：const 数据类型 常量名字 = 常量值，符号常量必须在定义的时候赋值</li>
<li>宏常量：#define MAX 1000  // 特别注意，不可以写 “ ; ” 号，且宏常量名字要全部大写</li>
</ol>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol>
<li>程序在运行期间，数据可变</li>
<li>变量的定义就是给变量命名的时候分配内存空间，这就是为了存储数据</li>
<li>数据类型存在就是为了给变量分配合适的内存空间</li>
</ol>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ol>
<li>基本整数类型：int，4字节</li>
<li>短整型：short，2字节</li>
<li>长整型：long，后缀为L或l，windows为4字节，Linux为4字节，8字节</li>
<li>长长整型：long long，后缀为LL或ll，8字节</li>
<li>按符号分：有符号整数（signed）、无符号整数（unsigned，后缀为U或u）</li>
</ol>
<h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><ol>
<li>单精度 float，占4字节，7位有效数字</li>
<li>双精度 double，占8字节，精确到15-16位有效数字</li>
<li>扩展精度 long double</li>
<li>浮点数在计算机中是近似存储的，不要比较浮点数的大小，比较浮点数的大小可以用两个数的差值来比较大小，满足规定的精度就可以了</li>
<li>表示的有效数字范围不同</li>
<li>默认的是双精度数据，所以float数据后面需要加f，不加的话会出现数据类型转换，损失精度，例如：float f1 = 3.14；这就会发生double -&gt; float</li>
<li>默认情况下，输出一个单精度或双精度小数，有效位数为6位。</li>
</ol>
<h4 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h4><ol>
<li>容纳单个字符的编码，实际上存储的也是整数。字符型变量不会把字符本身放到内存中存储，而是将该字符对应的ASCII编码的二进制数据存放到内存中</li>
<li>char ch = ‘a’; // 单引号，单引号里面只能写一个字符</li>
<li>占用1字节</li>
<li>‘a’ 的ASCII码值是97，’A’ 的ASCII值是65</li>
</ol>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><ol>
<li>取值只能是真（true，本质是1）或假（false，本质是0）</li>
<li>占1个字节</li>
<li>类型是：bool</li>
<li>非0的数字（正负整数 或 正负实数）代表真，0代表假</li>
</ol>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ol>
<li>有字符串常量</li>
<li>基本类型中没有字符串变量</li>
<li>C语言风格的字符串：char 变量名[] = “hello world”；// 采用了字符数组存放字符串</li>
<li>C++风格的字符串：string 变量名 = “hello world”;  // 在C++的标准库里有String类，但要包含头文件：#include<string></li>
</ol>
<h3 id="2-3-C-的基本运算"><a href="#2-3-C-的基本运算" class="headerlink" title="2.3 C++的基本运算"></a>2.3 C++的基本运算</h3><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ol>
<li><p>两个整数相除，结果依然是整数，小数部分会被去除。例如：10/20 的结果是0，10/3 的结果是3。除数也就是分母不得为0，这是非法的操作。</p>
</li>
<li><p>两个小数也可以相除：0.5 / 0.25 的结果就是2。运算的结果也可以是小数，例如：10.0 / 3的结果是3.33333</p>
</li>
<li><p>取模运算的本质就是取余数，基于除法运算，因为运算符右侧的数据不得为0，两个操作数都必须是整型数据。10 % 0 是错误操作</p>
</li>
<li><p>自增、自减运算符。前置：让变量先自增或自减，再运算。后置：让变量先运算，后自增或自减。</p>
</li>
<li><p>先乘除，后加减，同级自左向右</p>
</li>
</ol>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><ol>
<li>“ ! ” ，逻辑非</li>
<li>“ &amp;&amp; ”，逻辑与</li>
<li>“ || ”，逻辑或</li>
<li>返回值是真或假</li>
</ol>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ol>
<li>复合赋值运算符：&lt;&lt;=（移位）、&gt;&gt;=、&amp;=、^=、|=等</li>
<li>“ = ”</li>
</ol>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ol>
<li>两个表达式的比较，返回bool类型的值，也就是真假</li>
<li>“ == ” 等于</li>
<li>“ != ” 不等于</li>
</ol>
<h3 id="2-4-C-的输入输出"><a href="#2-4-C-的输入输出" class="headerlink" title="2.4 C++的输入输出"></a>2.4 C++的输入输出</h3><ol>
<li><p>调用预定义的功能模块实现</p>
</li>
<li><p>从外部数据读取数据</p>
</li>
<li><p>输入：cin &gt;&gt; 变量名；</p>
</li>
<li><p>输出：cout &lt;&lt; 变量名；</p>
</li>
</ol>
<h3 id="2-5-C-程序执行流程"><a href="#2-5-C-程序执行流程" class="headerlink" title="2.5 C++程序执行流程"></a>2.5 C++程序执行流程</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><ol>
<li>程序顺序执行，不发生跳转</li>
</ol>
<h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ol>
<li><p>if 语句：单选择、多选择、if 嵌套。if是选择语句，执行一种选择</p>
</li>
<li><p>三目运算符：表达式1？ 表达式2：表达式3；在C++中，三目运算符返回的是变量，可以继续赋值</p>
</li>
<li><p>switch（表达式）{</p>
<p>​    case 结果1：执行语句；break；</p>
<p>​    case 结果2：执行语句；break；</p>
<p>​    ……</p>
<p>​    default：执行语句；</p>
<p>} // 要防止case穿透，加上break</p>
</li>
<li><p>switch的执行效率要比 if 高</p>
</li>
</ol>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ol>
<li>while(判断条件){</li>
</ol>
<p>​        ……</p>
<p>​    }</p>
<ol start="2">
<li><p>do{</p>
<p>​    …</p>
<p>}while(判断条件)；</p>
</li>
<li><p>for(){</p>
<p>}</p>
</li>
</ol>
<h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><ol>
<li><p>break：出现在 switch、循环语句、嵌套循环，直接退出循环</p>
</li>
<li><p>continue：跳过本次循环</p>
</li>
<li><p>goto：无条件跳转语句；</p>
<p>语法：goto 标记；</p>
<pre class=" language-c++"><code class="language-c++">goto flag;
... // 跳过该语句
... // 跳过该语句
flag:
... // 直接执行该语句
exp：
int main() &#123;
    cout << "1" << endl;
    goto flag;
    cout << "2" << endl;
    cout << "3" << endl;
    flag:
    cout << "4" << endl;
&#125;
</code></pre>
</li>
</ol>
<h3 id="2-6-C-自定义类型之枚举类型"><a href="#2-6-C-自定义类型之枚举类型" class="headerlink" title="2.6 C++自定义类型之枚举类型"></a>2.6 C++自定义类型之枚举类型</h3><p>枚举类型：通过列出所有可取值来定义一种新类型</p>
<p><strong>注意：</strong>用不同的环境下，各个数据类型所占的字节数不同</p>
<p>​            变量声明以后要进行变量的初始化</p>
<h3 id="2-7-C-关键字"><a href="#2-7-C-关键字" class="headerlink" title="2.7 C++关键字"></a>2.7 C++关键字</h3><h4 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h4><p>统计数据类型所占内存的大小</p>
<p>sizeof（数据类型 或 具体的变量名）</p>
<h3 id="2-8-科学计数法"><a href="#2-8-科学计数法" class="headerlink" title="2.8 科学计数法"></a>2.8 科学计数法</h3><p>float f2 = 3e2； // 表示 f2 = 3*10^2</p>
<p>f2 = 3e-2; // 表示 f2 = 3*10^(-2)</p>
<h3 id="2-9-转义字符"><a href="#2-9-转义字符" class="headerlink" title="2.9 转义字符"></a>2.9 转义字符</h3><ol>
<li>用于表示不能显示出来的ASCII字符</li>
<li>\n 换行</li>
<li>\a 报警</li>
<li>\ \ 代表一个反斜杠\</li>
<li>\t 水平制表符，占八位（与前字符一共占八位），在输出的时候可以让结果看起来比较整齐</li>
</ol>
<h2 id="第三章-数组"><a href="#第三章-数组" class="headerlink" title="第三章 数组"></a>第三章 数组</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ol>
<li>存放数据类型相同的数据</li>
<li>数组是由连续内存位置组成的</li>
<li>可以通过下表访问数组元素</li>
<li>数组的首地址和数组的第一个元素的地址是相同的</li>
</ol>
<h3 id="3-2-一维数组"><a href="#3-2-一维数组" class="headerlink" title="3.2 一维数组"></a>3.2 一维数组</h3><ol>
<li>定义方式：<ul>
<li>数据类型 数组名 [ 数组长度 ]；</li>
<li>数据类型 数组名 [ 数组长度 ] = { 值1， 值2， … }；未赋值的位置会用默认值填充</li>
<li>数据类型 数组名[ ] = { 值1，值2，…  }；</li>
<li>数据类型 数组名[ ]；不允许这样定义数组</li>
</ul>
</li>
<li>数组名的用途：<ul>
<li>通过数组名可以获取数组在内存中的首地址(十六进制数)：直接输出数组名</li>
<li>可以统计整个数组在内存中的长度</li>
<li>数组名是常量，不可以进行赋值</li>
</ul>
</li>
</ol>
<h3 id="3-3-二维数组"><a href="#3-3-二维数组" class="headerlink" title="3.3 二维数组"></a>3.3 二维数组</h3>

1. 定义方式：
   * 数据类型  数组名[ 行数 ] [ 列数 ]；
   * 数据类型  数组名[ 2 ] [ 2 ] = {{ 行1值1，行1值2 }，{ 行2值1，行2值2  }}；// 代码可读性更好
   * 数据类型  数组名[ 行数 ] [ 列数 ] = { 值1，值2，值3，...  }; // 没有初始化的就会填充默认值，自动划分行列
   * 数据类型  数组名[ ] [ 列数 ] = { 数据1，数据2，数据3，...  }；
   * 一定要指定列数，否则不能划分二维数组的行
2. 二维数组名的用途：
   * 查看二维数组所占的内存空间：sizeof(数组名 / 数组名[行] )；
   * 查看二维数组的首地址
   * 第一行的地址 = 数组首地址 = 二维数组的第一个元素的地址



<h2 id="第四章-函数"><a href="#第四章-函数" class="headerlink" title="第四章 函数"></a>第四章 函数</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><ol>
<li>代码复用，实现函数的功能</li>
</ol>
<h3 id="4-2-函数的定义"><a href="#4-2-函数的定义" class="headerlink" title="4.2 函数的定义"></a>4.2 函数的定义</h3><ol>
<li><p>返回值类型</p>
</li>
<li><p>函数名</p>
</li>
<li><p>参数列表</p>
</li>
<li><p>函数体语句</p>
</li>
<li><p>return表达式</p>
<pre><code>返回值类型 函数名（参数列表该参数列表是形参）&#123;
    函数体语句;
    return 值;
&#125;
</code></pre>
</li>
</ol>
<h3 id="4-3-函数调用"><a href="#4-3-函数调用" class="headerlink" title="4.3 函数调用"></a>4.3 函数调用</h3><ol>
<li><p>调用语法：</p>
<pre class=" language-c++"><code class="language-c++">返回类型 接收返回值的地址或变量 = 函数名称（参数列表，传递的是实参）;
</code></pre>
</li>
</ol>
<h3 id="4-4-值传递"><a href="#4-4-值传递" class="headerlink" title="4.4 值传递"></a>4.4 值传递</h3><ol>
<li>首先要定义函数</li>
<li>函数进行  值传递（值传递是区别于地址传递的）  时，并不会影响实参，只是影响了形参</li>
</ol>
<h3 id="4-5-函数的常见样式"><a href="#4-5-函数的常见样式" class="headerlink" title="4.5 函数的常见样式"></a>4.5 函数的常见样式</h3><ol>
<li><p>无参无返回值</p>
<pre><code>void test01()&#123;
    函数体;
&#125;
调用：test01();
</code></pre>
</li>
<li><p>有参无返回值</p>
<pre><code>void test02(形参列表)&#123;
    函数体;
&#125;
调用：test02(实参列表);
</code></pre>
</li>
<li><p>无参有返回值</p>
<pre><code>返回值类型 test03()&#123;
    函数体;
    return 返回值;
&#125;
调用：返回值类型 接收返回值的变量或地址 = test03();
</code></pre>
</li>
<li><p>有参有返回值</p>
<pre><code>返回值类型 test03(形参列表)&#123;
    函数体;
    return 返回值;
&#125;
调用：返回值类型 接收返回值的变量或地址 = test03(实参列表);
</code></pre>
</li>
</ol>
<h3 id="4-6-函数声明"><a href="#4-6-函数声明" class="headerlink" title="4.6 函数声明"></a>4.6 函数声明</h3><ol>
<li><p>函数的定义是函数的具体实现，而函数的声明在函数定义之前，告诉编译器函数的存在</p>
</li>
<li><p>函数的声明可以写多次，但是函数的定义只能写一次</p>
</li>
<li><p>普通函数的定义；</p>
<p>main()函数；</p>
<p>// 这样普通函数就不需要声明</p>
</li>
<li><p>普通函数声明；</p>
<p>main()函数；</p>
<p>普通函数定义；</p>
<p>// 这样普通函数就需要先声明</p>
</li>
</ol>
<h3 id="4-7-函数的分文件编写"><a href="#4-7-函数的分文件编写" class="headerlink" title="4.7 函数的分文件编写"></a>4.7 函数的分文件编写</h3><ol>
<li><p>让代码结构更加清晰</p>
</li>
<li><p>函数的分文件编写步骤：</p>
<ul>
<li><p>创建后缀名为 .h 的头文件，并在头文件中写出函数的声明</p>
<pre><code>#include&lt;iostream&gt;
using namespace std; // 在 .h 头文件中要包含iostream和命名空间

// 函数的声明，在.h的头文件中声明
void swap(int a, int b);
</code></pre>
</li>
<li><p>创建后缀名为 .cpp 的源文件，并在源文件中写出函数的定义</p>
<pre><code>#include&quot;swap.h&quot;  // 要把 .h 的头文件包含到 .cpp 文件中

// 函数定义，定义交换两数，不需要返回值
void swap(int num1, int num2) &#123;
    int temp = 0;
    temp = num1;
    num1 = num2;
    num2 = temp;
    cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
    cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;
&#125;
</code></pre>
</li>
<li><p>创建一个测试的源文件</p>
<pre><code>#include&lt;iostream&gt;
#include&quot;swap.h&quot;  // 要引入 .h 的头文件
using namespace std;

int main()&#123;
    swap(10, 20);
    return 0;
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="第五章-指针"><a href="#第五章-指针" class="headerlink" title="第五章 指针"></a>第五章 指针</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><ol>
<li><p>设置一个变量 a 来保存另一个变量 b 的地址，那么该变量 a 就是指针变量</p>
</li>
<li><p>指针变量的定义：</p>
<p>数据类型  *  指针变量名；</p>
<pre><code>int a = 10;
int * p = &amp;a; // 将a的地址取出赋值到指针变量p,p的值就是变量a的地址，而*p就是变量a的值
</code></pre>
</li>
<li><p>指针变量的使用：</p>
<p>可以通过  解引用(* 代表解引用，找到指针指向的内存中的数据)  的方式来找到指针指向的内存</p>
<pre><code>*p == a; // true
</code></pre>
</li>
<li><p><strong>特别注意：</strong></p>
<p>*++p : 会先执行指针后移再取值</p>
</li>
</ol>
<h3 id="5-2-指针所占的内存空间"><a href="#5-2-指针所占的内存空间" class="headerlink" title="5.2 指针所占的内存空间"></a>5.2 指针所占的内存空间</h3><ol>
<li>在32位操作系统下： 不管是什么类型的指针都占用4个字节空间</li>
<li>在64位系统下，指针占用8个字节的内存空间</li>
<li>特别注意：p才是指针变量存放了地址值，*p通过解引用，它的值是p中存放的地址指向的变量的值</li>
<li>*p 占用的内存空间跟变量 a 所占的内存空间大小相同</li>
<li>*p是变量a的引用</li>
<li>*p被赋予新的值，变量a也会随之改变，但 p 中存放的地址仍然是变量 a 的地址</li>
</ol>
<h3 id="5-3空指针和野指针"><a href="#5-3空指针和野指针" class="headerlink" title="5.3空指针和野指针"></a>5.3空指针和野指针</h3><ol>
<li><p>空指针用于给指针变量进行初始化，NULL指针是指向编号为 0 的空间</p>
<p>int *p = null；</p>
</li>
<li><p>空指针不可以进行访问：0-255之间的内存编号是系统占用的，因此不可以访问</p>
</li>
<li><p>野指针指向了非法的内存空间</p>
<pre><code>int * p = (int *)0x1100; // 强制将十六进制转为int类型的指针，随便拿一个地址进行操作
cout&lt;&lt; *p &lt;&lt; endl; // 在程序中要避免这种情况
</code></pre>
</li>
<li><p>空指针和野指针都不是我们申请的空间，因此不要访问，这是一种危险的行为</p>
</li>
</ol>
<h3 id="5-4-const修饰指针"><a href="#5-4-const修饰指针" class="headerlink" title="5.4 const修饰指针"></a>5.4 const修饰指针</h3><ol>
<li><p>const修饰指针–常量指针：</p>
<pre><code>const int * p = &amp;a;
// 指针的指向可以修改（也就是p中存放的地址可以修改，但是*p的值不可以修改），但是指针指向的值不可以修改
</code></pre>
</li>
<li><p>const修饰常量 – 指针常量</p>
<pre><code>int * const p = &amp;a;
// 指针的指向不可以修改（p中存放的地址不可以修改），指针指向的值可以修改（*p的值可以修改）
</code></pre>
</li>
<li><p>const既修饰指针，又修饰常量</p>
<pre><code>const int * const p = &amp;a;
// 指针的指向不可以修改，指针指向的值也不可以修改
</code></pre>
</li>
<li><p>const修饰啥，啥就不可修改</p>
</li>
</ol>
<h3 id="5-5-指针和数组"><a href="#5-5-指针和数组" class="headerlink" title="5.5 指针和数组"></a>5.5 指针和数组</h3><ol>
<li><p>利用指针访问数组元素</p>
<pre><code>int a[] = &#123;1, 2, 3, 4&#125;;
int * p = a; // 数组名就是数组的首地址
cout&lt;&lt;*p&lt;&lt;endl; // 输出的值就是数组的第一个元素的值
p++; // 指针后移，p的地址就是数组中第二个元素的地址
cout&lt;&lt;*p&lt;&lt;endl; // 此时的值就是数组中第二个元素的值
</code></pre>
</li>
</ol>
<h3 id="5-6-指针和函数"><a href="#5-6-指针和函数" class="headerlink" title="5.6 指针和函数"></a>5.6 指针和函数</h3><ol>
<li><p>值传递</p>
<pre><code>void swap(int num1, int num2) &#123;
    int temp = 0;
    temp = num1;
    num1 = num2;
    num2 = temp;
    cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl;
    cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl;
&#125;
// 调用：swap(a, b);
</code></pre>
</li>
<li><p>地址传递：地址传递可以修改实参</p>
<pre><code>// 该函数是指交换了变量的值，变量的地址不改变
void swap(int * num1, int * num2) &#123;
    int temp = 0;
    temp = *num1;
    *num1 = *num2;
    *num2 = temp;
&#125;
// 调用：swap(&amp;a, &amp;b);
// *num1相当于变量a的引用，*num1的值改变，变量a的值也就改变了，但是变量a的地址和num1中存储的地址值是一样的
</code></pre>
</li>
</ol>
<h2 id="第六章-结构体"><a href="#第六章-结构体" class="headerlink" title="第六章 结构体"></a>第六章 结构体</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h3><ol>
<li>用户自定义的数据类型，允许用户存储不同的数据类型</li>
</ol>
<h3 id="6-2-结构体定义和使用"><a href="#6-2-结构体定义和使用" class="headerlink" title="6.2 结构体定义和使用"></a>6.2 结构体定义和使用</h3><ol>
<li><p>语法：</p>
<p>struct  Student { // 结构体名首字母大写</p>
<p>​        String  name； // 可以理解为属性，用C++的字符串要包含头文件：#include<string></p>
<p>​        int   age；</p>
<p>​        int  score；</p>
<p>} student03；// 在定义结构体的同时创建结构体变量student03，然后可以通过 . 运算符来初始化，这种方式使用较少</p>
</li>
<li><p>通过学生类型创建具体学生</p>
<ul>
<li>struct Student student01；</li>
<li>struct Student student02 = {“李四”，19，80}；</li>
<li>在定义结构体的同时顺便创建结构体变量</li>
</ul>
</li>
<li><p>访问结构体变量中的属性：通过 . 运算符访问结构体中的属性</p>
<ul>
<li>student01.name = “张三”;</li>
<li>student01.age = 18;</li>
<li>student01.score = 100;</li>
<li>cout&lt;&lt;student01.name&lt;&lt;endl;</li>
<li>cout&lt;&lt;student01.age&lt;&lt;endl;</li>
<li>cout&lt;&lt;student01.score&lt;&lt;endl;</li>
</ul>
</li>
<li><p>struct 在结构体创建变量的时候可以省略，但在定义结构体时该关键字不可以省略</p>
</li>
</ol>
<h3 id="6-3-结构体数组"><a href="#6-3-结构体数组" class="headerlink" title="6.3 结构体数组"></a>6.3 结构体数组</h3><ol>
<li><p>语法：</p>
<pre><code>struct 结构体名 数组名[元素个数] = &#123;&#123;&#125;, &#123;&#125;, &#123;&#125;,...&#125;；
</code></pre>
</li>
<li><p>实例</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

// 创建结构体
struct Student
&#123;
    string name;
    int age;
    int score;
&#125;;

int main() &#123;
    // 创建结构体数组
    struct Student students[] = &#123;
        &#123;&quot;张三&quot;, 18, 100&#125;,
        &#123;&quot;李四&quot;, 28, 90&#125;,
        &#123;&quot;王五&quot;, 38, 66&#125;
    &#125;;

    // 访问结构体数组中的数据
    students[2].name = &quot;赵六&quot;;
    students[2].age = 49;
    students[2].score = 80;
    
    // 遍历结构体数组
    for (int i = 0; i &lt; 3; i++)
    &#123;
        cout &lt;&lt; students[i].name &lt;&lt; &quot;\t&quot; &lt;&lt; students[i].age &lt;&lt; &quot;\t&quot; &lt;&lt; students[i].score &lt;&lt; &quot;\t&quot; &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="6-4-结构体指针"><a href="#6-4-结构体指针" class="headerlink" title="6.4 结构体指针"></a>6.4 结构体指针</h3><p>利用操作符：-&gt; 可以通过 结构体指针 访问结构体属性</p>
<pre><code>    // 创建学生结构变量,struct关键字可以省略
    struct Student student01 = &#123;&quot;张三&quot;, 20, 90&#125;;
    
    // 通过指针指向结构体变量,struct关键字可以省略
    struct Student * p = &amp;student01;

    // 通过指针访问结构体变量中的数据
    cout &lt;&lt; p-&gt;name &lt;&lt; endl;
    cout &lt;&lt; p-&gt;age &lt;&lt; endl;
    cout &lt;&lt; p-&gt;score &lt;&lt; endl;
</code></pre>
<h3 id="6-5-结构体嵌套结构体"><a href="#6-5-结构体嵌套结构体" class="headerlink" title="6.5 结构体嵌套结构体"></a>6.5 结构体嵌套结构体</h3><ol>
<li><p>结构体中的成员可以是另一个结构体</p>
</li>
<li><pre><code>// Student结构体
struct Student
&#123;
    string name;
    int age;
    int score;
&#125;;

// Teacher结构体
struct Teacher
&#123;
    int id;
    string name;
    int age;
    struct Student student; // 要在Teacher结构体前先定义Student结构体
&#125;;
</code></pre>
</li>
<li><p>使用</p>
<pre><code>    // 创建 Teacher 结构体变量 teacher01
    Teacher teacher01 = &#123;10000, &quot;老王&quot;, 50&#125;;
    // 给 student 初始化
    teacher01.student.name = &quot;小豪&quot;;
    teacher01.student.age = 23;
    teacher01.student.score = 80;
    cout &lt;&lt; teacher01.id &lt;&lt; endl;
    cout &lt;&lt; teacher01.name &lt;&lt; endl;
    cout &lt;&lt; teacher01.age &lt;&lt; endl;
    cout &lt;&lt; teacher01.student.name &lt;&lt; endl;
    cout &lt;&lt; teacher01.student.age &lt;&lt; endl;
    cout &lt;&lt; teacher01.student.score &lt;&lt; endl;
</code></pre>
</li>
<li><p>string 类型的数据占40个字节</p>
<pre><code>    cout &lt;&lt; sizeof(teacher01) &lt;&lt; endl; // 104个字节
    cout &lt;&lt; sizeof(string) &lt;&lt; endl; // 40个字节
    cout &lt;&lt; sizeof(Student) &lt;&lt; endl; // 48个字节
</code></pre>
</li>
</ol>
<h3 id="6-6-结构体作为函数参数"><a href="#6-6-结构体作为函数参数" class="headerlink" title="6.6 结构体作为函数参数"></a>6.6 结构体作为函数参数</h3><ol>
<li><p>将结构体作为参数向函数中传递实参</p>
</li>
<li><p>值传递：在printStudent(struct Student student)中修改数据不影响实参的数据</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

// Student结构体
struct Student
&#123;
    string name;
    int age;
    int score;
&#125;;

// 打印学生的信息
void printStudent(struct Student student) 
&#123;
    cout &lt;&lt; student.name &lt;&lt; endl;
    cout &lt;&lt; student.age &lt;&lt; endl;
    cout &lt;&lt; student.score &lt;&lt; endl;
&#125;

int main() &#123;
    // 结构体作为函数的参数：将学生传入一个参数中，打印学生的信息
    // 创建学生变量
    struct Student student01 = &#123;&quot;张三&quot;, 20, 100&#125;;
    printStudent(student01);
&#125;
</code></pre>
</li>
<li><p>地址传递：在printStudent(struct Student * student)中修改数据影响实参的数据，这或许在某些场景下不是一个好方案</p>
<p>地址传递：将形参改为指针，可以节省内存空间，而且不会复制新的副本（student）出来</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

// Student结构体
struct Student
&#123;
    string name;
    int age;
    int score;
&#125;;

// 打印学生的信息
void printStudent(struct Student * student) 
&#123;    
    student-&gt;name = &quot;李四&quot;;
    cout &lt;&lt; student-&gt;name &lt;&lt; endl; // 输出了“李四”
    cout &lt;&lt; student-&gt;age &lt;&lt; endl;
    cout &lt;&lt; student-&gt;score &lt;&lt; endl;
&#125;

int main() &#123;
    // 结构体作为函数的参数：将学生传入一个参数中，打印学生的信息
    // 创建学生变量
    struct Student student01 = &#123;&quot;张三&quot;, 20, 100&#125;;
    printStudent(&amp;student01);
    // 在printStudent(&amp;student01);中修改了姓名，那么也会输出 “李四”
    cout &lt;&lt; student01.name &lt;&lt; endl;
&#125;
</code></pre>
</li>
</ol>
<h3 id="6-7-结构体中的const"><a href="#6-7-结构体中的const" class="headerlink" title="6.7 结构体中的const"></a>6.7 结构体中的const</h3><ol>
<li><p>用 const 防止误操作</p>
</li>
<li><p>const的使用场景</p>
<pre><code>// 打印学生的信息
void printStudent(const struct Student * student) 
&#123;    
    // student-&gt;name = &quot;李四&quot;; 加入了const之后，一旦有修改操作就会报错，可以方式我们的误操作 
    cout &lt;&lt; student-&gt;name &lt;&lt; endl; // 输出了“李四”
    cout &lt;&lt; student-&gt;age &lt;&lt; endl;
    cout &lt;&lt; student-&gt;score &lt;&lt; endl;
&#125;
// 使用了地址传递实参，和const关键字，既可以减小内存的使用，又可以防止修改数据而影响实参的误操作
</code></pre>
</li>
</ol>
<h1 id="C-第二阶段"><a href="#C-第二阶段" class="headerlink" title="C++第二阶段"></a>C++第二阶段</h1><p>本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓</p>
<h2 id="第一章-内存分区模型"><a href="#第一章-内存分区模型" class="headerlink" title="第一章 内存分区模型"></a>第一章 内存分区模型</h2><ol>
<li><p>C++在执行时，将内存大方向分为4个区域</p>
<ul>
<li><p>代码区：存放  <strong>函数体</strong>  的二进制代码，由操作系统进行管理</p>
</li>
<li><p>全局区：存放  <strong>全局变量（在函数以外的定义的变量）</strong> 和  <strong>静态变量</strong>(static int a = 10;)  以及  <strong>常量</strong></p>
</li>
<li><p>栈区：由编译器自动分配释放，存放  <strong>函数的参数值</strong>，  <strong>局部变量（在函数内部定义的变量）</strong>等</p>
</li>
<li><p>堆区：由  <strong>程序员</strong>  分配和释放，若程序员不释放，<strong>程序结束时由操作系统回收</strong></p>
</li>
</ul>
</li>
<li><p>四区存在的意义：</p>
<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p>
</li>
</ol>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><ol>
<li>在程序编译后，生成了.exe的可执行程序，未执行该程序前分为两个区域</li>
<li>代码区：<ul>
<li>存放CPU执行的机器指令（二进制指令）</li>
<li>代码区是共享的，共享的目的是对于频繁调用被执行的程序，只需要在内存中有一份代码即可</li>
<li>代码区是只读的，使其只读的原因是防止程序意外地修改了代码的指令</li>
</ul>
</li>
<li>全局区：<ul>
<li><strong>全局变量（在函数以外的定义的变量）</strong>  和  <strong>静态变量(static int a = 10;)</strong>  存放在此</li>
<li>全局区还包含了  <strong>常量区</strong>、  <strong>字符串常量（”hello world”）</strong>  和  <strong>其他全局定义的常量(全局定义的const int a = 10;)</strong>  也存放在此</li>
<li>该区的数据在程序结束后由操作系统释放</li>
</ul>
</li>
</ol>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><ol>
<li><p>栈区：</p>
<ul>
<li><p>由编译器自动  分配  和  释放，存放函数的参数值，局部变量等</p>
</li>
<li><p>注意事项：不要返回局部变量的地址</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

int * func() &#123; // 可以返回一个指针
    int a = 10; // 局部变量存放在栈区，栈区的数据在函数执行完后会自动释放
    cout &lt;&lt; &quot;func()函数中变量a的地址：&quot; &lt;&lt; &amp;a &lt;&lt; endl; // func()函数中变量a的地址：00000076ECB8F7E4
    return &amp;a; // 返回局部变量的地址
&#125;

int main() &#123;
    int * p = func(); // 指针变量 p 接收了函数func()返回的局部变量 a 的地址值
    cout &lt;&lt; &quot;输出指针p中存放的地址值：&quot; &lt;&lt; p &lt;&lt; endl; // 输出指针p中存放的地址值：00000076ECB8F7E4，第一次可以打印正确是因为编译器做了保留
    cout &lt;&lt; &quot;输出指针p指向的内存中的值&quot; &lt;&lt; *p &lt;&lt; endl; // 输出指针p指向的内存中的值-858993460，第二次这个数据就不保留了，因此不可以返回局部变量的地址
    cout &lt;&lt; &quot;再次输出指针p指向的内存中的值&quot; &lt;&lt; *p &lt;&lt; endl; // 再次输出指针p指向的内存中的值-858993460
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>堆区：</p>
<ul>
<li><p>由程序员分配释放，若程序员不释放，程序结束后由操作系统回收</p>
</li>
<li><p>在C++中主要利用new在堆区开辟空间</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

int * func() &#123;
    // 利用new关键字可以将数据开辟到堆区
     int * p = new int(10); // new运算符会返回在堆区开辟的内存的地址，指针p本质上也是局部变量，存在栈区，但是其中存放的地址编号是指向了堆区的数据
    cout &lt;&lt; p &lt;&lt; endl; // 0000013BF43AA240
    return p;
&#125;
int main() &#123;
    int* q = func();
    cout &lt;&lt; *q &lt;&lt; endl; // 10
    cout &lt;&lt; q &lt;&lt; endl; // 0000013BF43AA240
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><ol>
<li>C++利用new操作符在堆区开辟数据</li>
<li>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <strong>delete</strong></li>
<li>new返回的是该数据类型的指针也就地址</li>
<li>利用new创建数组：int* arr = new int[10]；此时这个数组存放到了堆区</li>
<li>释放数组：delete[] arr；</li>
</ol>
<h2 id="第二章-引用"><a href="#第二章-引用" class="headerlink" title="第二章 引用"></a>第二章 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><ol>
<li><p>给一个变量起别名</p>
<pre><code>int a = 10; // &amp;a中4个字节，存放10
int &amp;b = a; 
b = 20; // a的值也就改为了20，因为 变量a 和 别名b 指向了同一块内存空间
</code></pre>
</li>
<li><p>语法：数据类型  &amp;别名 = 变量原名；</p>
</li>
</ol>
<h3 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h3><ol>
<li><p>引用必须初始化：也就是不可以int &amp;b；这样就是未初始化</p>
</li>
<li><p>引用在初始化后，就不可以改变了</p>
<pre><code>int a = 10;
int &amp;b = a; // 将变量b设置为变量a的别名以后，就不可以设置为别的变量的引用了
int c = 20;
// int &amp;b = c; // 不可以这样操作，引用b不可以再指向别的内存空间了
b = c; // 这是可以的，因为这仅仅是赋值操作，而不是修改引用
</code></pre>
</li>
</ol>
<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><ol>
<li><p>函数传参时，可以利用引用的技术让形参修饰实参</p>
</li>
<li><p>可以简化指针修改实参</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 引用的方式交换数据，这就改变了实参中的值
void swap(int &amp;a, int &amp;b) &#123;
    int temp;
    temp = a;
    a = b;
    b = temp;
&#125;

int main() &#123;
    int a = 10;
    int b = 20;
    swap(a, b); 
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
&#125;
</code></pre>
</li>
<li><p>值传递、地址传递、引用传递</p>
</li>
</ol>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><ol>
<li><p>不要返回局部变量的引用，局部变量创建在栈区，由编译器分配销毁，在执行完函数以后，编译器就会销毁</p>
</li>
<li><p>函数调用可以作为左值</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 引用的方式交换数据，这就改变了实参中的值
void swap(int &amp;a, int &amp;b) &#123;
    int temp;
    temp = a;
    a = b;
    b = temp;
&#125;

int&amp; func01() &#123;
    int a = 10; // 局部变量，存放在栈区，在函数执行结束之后，编译器自动释放a指向的内存，存在风险
    return a;
&#125;

int&amp; func02() &#123;
    static int a = 10; // 静态变量存放在全局区，全局区上的数据在程序结束以后才会被释放
    return a;
&#125;

int main() &#123;
    int&amp; b = func01();
    cout &lt;&lt; b &lt;&lt; endl; // 第一次结果正确，是因为编译器做了保留
    cout &lt;&lt; b &lt;&lt; endl; // 第二次结果是乱码，因为func01()中的变量a内存已经释放
    
    int&amp; c = func02(); // c是func02()函数中a的别名，c和func02()中的a内存地址是一样的
    cout &lt;&lt; c &lt;&lt; endl;
    cout &lt;&lt; c &lt;&lt; endl;
    
    // 函数调用可以作为左值,func02()作为了左值
    func02() = 1000; // 将1000赋值给了func02()中的静态变量a,而c又是a的引用，也就是c指向了变量a的内存地址
    cout &lt;&lt; c &lt;&lt; endl; // 那么此时的输出就是1000
    cout &lt;&lt; c &lt;&lt; endl;
&#125;
</code></pre>
</li>
</ol>
<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><ol>
<li><p>引用的本质在C++内部实现是一个指针常量</p>
<pre><code>void func(int&amp; ref)&#123; // 自动转化为 int * const ref = &amp;a;
    ref = 100; 
&#125;

int main()&#123;
    int a = 10;
    
    int&amp; ref = a; // 自动转换为 int * const ref = &amp;a; 这就是指针常量，该常量的指向的地址不可以修改，但是该常量中存放发地址指向的值是可以改变的
    
    ref = 20; // 这是允许的
    
    func(a); // a传入func函数以后，也进行了引用
&#125;
</code></pre>
<ol start="2">
<li>引用一旦初始化后就不可以改变：这就是因为其本质的原因</li>
<li>C++推荐使用引用</li>
</ol>
</li>
</ol>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><ol>
<li><p>常量引用用来修饰形参，防止误操作</p>
</li>
<li><p>引用必须引用一块合法的内存空间：int &amp;b = 10；这是错误的</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

void showValue(const int&amp; val) &#123;
    // val = 1000; 加上const以后，引用就不可以修改了，这样就防止了修改数据的误操作 
    cout &lt;&lt; val &lt;&lt; endl;
&#125;

int main() &#123;
    int a = 10;
    // int&amp; b = 10; // 这是错误的，引用必须引用一块合法的内存空间

    // 加上const之后，编译器将代码修改为：int temp = 10; const int&amp; b = temp;
    const int&amp; b = 10; // 这是可以的,但是加上const就不可以修改了,引用b不可以修改

    // 修饰形参防止误操作
    int val = 100;
    showValue(val);
    cout &lt;&lt; val &lt;&lt; endl;
&#125;
</code></pre>
</li>
</ol>
<h2 id="第三章-函数提高"><a href="#第三章-函数提高" class="headerlink" title="第三章 函数提高"></a>第三章 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><ol>
<li><p>函数的形参列表可以被赋予默认值的</p>
</li>
<li><p>语法：</p>
<pre><code>返回值类型 函数名(参数类型 参数a = 10, ...)

int func(int a, int b = 10, int c = 30)&#123;
    函数体;
&#125;
调用：
func(10); // 10被赋予了形参a
func(10, 20) // 10被赋予了形参a，20被赋予了形参b
// 优先使用传入的实参，若没有实参传入，则使用默认值
</code></pre>
</li>
<li><p>注意：</p>
<ul>
<li><p>如果某个位置已经有了默认参数，那么从这个位置之后，从左到右都必须设置默认值</p>
</li>
<li><p>如果函数的声明有默认参数，函数的实现就不能有默认参数了</p>
<pre><code>// 声明和实现只能有一个有默认参数
int func(int a, int b = 20, int c = 30);

int func(int a, int b, int c)&#123; // 调用该函数的时候，若没有实参传入，会使用该函数声明的默认值
    return a + b + c; 
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p>语法：返回值类型  函数名(数据类型) {函数体;}</p>
<pre><code>// 占位参数可以有默认参数
void func01(int a, int)&#123; // 第二个int起到占位的作用，必须传入相应的实参
    
&#125;

void func02(int a, int = 10)&#123;

&#125;

int main()&#123;
    int a = 10;
    func01(a, 10);
    func02(a); // 第二个参数会使用默认值
&#125;
</code></pre>
<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><ol>
<li><p>函数名可以相同，提高复用性</p>
</li>
<li><p>条件：</p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数类型不同，或者参数个数不同，或者顺序不同</li>
</ul>
<pre><code>#include&lt;iostream&gt;
using namespace std;

void func() &#123;
    // 函数体
&#125;
void func(int a) &#123;
    // 函数体
&#125;

void func(int a, int b) &#123;
    // 函数体
&#125;

void func(string name) &#123;
    // 函数体;
&#125;

void func(int age, string name) &#123;
    // 函数体
&#125;

void func(string name, int age) &#123;
    // 函数体
&#125;

int main() &#123;
    func();
    func(10);
    func(10, 20);
    func(&quot;hello&quot;);
    func(&quot;jack&quot;, 20);
    func(20, &quot;jack&quot;);
&#125;
</code></pre>
</li>
<li><p>函数的返回值不可以作为函数重载的条件，也就是函数返回类型不会区别重载的函数</p>
</li>
<li><p>引用作为重载条件</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

void func(int&amp; a) &#123;
    // 函数体
&#125;

void func(const int&amp; a) &#123; // 将常数10传入该函数以后，const int&amp; a = 10;是合法的
    // 函数体
&#125;

int main()&#123;
    int a = 10;
    func(a); // 调用了func(int&amp; a);
    func(10); // 调用了func(const int&amp; a); int&amp; a = 10是不合法的，所以不会调用func(int&amp; a);
&#125;
</code></pre>
</li>
<li><p>函数重载碰到函数默认参数</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

void func(int a) &#123;

&#125;

void func(int a, int b = 10) &#123;
    // 函数体
&#125;

int main()&#123;
    // func(10); // 这就报错了，因此这样调用编译器就不知道该调用哪个重载函数了,这就出现了歧义
    func(10, 20); // 这肯定没有问题
&#125;
</code></pre>
</li>
</ol>
<h2 id="第四章-类和对象"><a href="#第四章-类和对象" class="headerlink" title="第四章 类和对象"></a>第四章 类和对象</h2><p>C++的三大特性：封装、继承、多态</p>
<p>对象有属性和行为</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义："><a href="#4-1-1-封装的意义：" class="headerlink" title="4.1.1 封装的意义："></a>4.1.1 封装的意义：</h4><ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物</p>
</li>
<li><p>类中的属性和行为统称为成员</p>
</li>
<li><p>属性称为成员属性或成员变量</p>
</li>
<li><p>行为称为成员函数或成员方法</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Student
&#123;
public:
    // 属性
    string name;
    string id;

    // 行为
    void showInfo() &#123;
        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; &quot;学号：&quot; &lt;&lt; id &lt;&lt; endl;
    &#125;

    void setName(string name) &#123;
        this-&gt;name = name;
    &#125;

    void setId(string id) &#123;
        this-&gt;id = id;
    &#125;
&#125;;

int main() &#123;
    Student student01; // 实例化
    student01.setName(&quot;张三&quot;);
    student01.setId(&quot;12345678&quot;);
    student01.showInfo();
&#125;
</code></pre>
</li>
<li><p>将属性和行为加以控制权限</p>
<p>公共权限：public，成员类内可以访问，类外也可以访问</p>
<p>保护权限：protected，类内可以访问，类外不可以访问，父类中的保护权限的内容子类可以访问</p>
<p>私有权限：private，类内可以访问，类外不可以访问，父类中私有权限的内容子类不可以访问</p>
<p>默认权限：private</p>
</li>
</ul>
<h4 id="4-1-2-struct-结构体-和class-类-的区别："><a href="#4-1-2-struct-结构体-和class-类-的区别：" class="headerlink" title="4.1.2 struct(结构体)和class(类)的区别："></a>4.1.2 struct(结构体)和class(类)的区别：</h4><ol>
<li>class 的默认权限是 private</li>
<li>struct 的默认权限是 public</li>
</ol>
<h4 id="4-1-3-成员属性私有化"><a href="#4-1-3-成员属性私有化" class="headerlink" title="4.1.3 成员属性私有化"></a>4.1.3 成员属性私有化</h4><ol>
<li><p>将所有成员属性私有化，可以字节控制读写的权限</p>
</li>
<li><p>对于写可以检测数据的有效性（可以在setter方法中设置set的条件）</p>
</li>
</ol>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><ol>
<li>对象的初始化和清理是非常重要的安全问题，一个对象或者变量没有初始化，对其使用后果是未知的</li>
<li>使用完一个对象和变量，没有及时清理，也会造成一定的安全问题</li>
<li>构造函数和析构函数解决上述两个问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理</li>
<li>对象的初始化和清理工作是编译器强制要求的</li>
<li>不写构造函数和析构函数编译器会提供空实现的构造函数和析构函数</li>
</ol>
<p><strong>构造函数</strong>：主要用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</p>
<pre><code>类名()&#123;
    函数体;
&#125;

没有返回值类型，不写void
函数名和类名相同
构造函数可以有参数，可以重载
程序在调用对象时候会自动调用构造，无须手动调用，只会调用一次
</code></pre>
<p><strong>析构函数</strong>：用于对象销毁前系统的自动调用，执行一些清理工作</p>
<pre><code>~类名()&#123;
    函数体;
&#125;
没有返回值，也不写void
函数名和类型相同，在函数名前面加 ~
析构函数不可以有参数，不可以发发生重载
对象在销毁前，会自动调用析构函数
创建了几个对象，就调用几次
</code></pre>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person
&#123;
public:
    // 构造函数
    Person() &#123;
        cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;
    &#125;
    
    // 析构函数
    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;
    &#125;

private:

&#125;;


int main() &#123;
    Person person;
&#125;
</code></pre>
<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p><strong>构造函数分类</strong>：</p>
<ol>
<li><p>有参构造</p>
<pre><code>// 有参构造函数
Person(string name, int age) &#123;
    cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;
&#125;
</code></pre>
</li>
<li><p>无参构造</p>
<pre><code>// 无参构造函数
Person() &#123;
    cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;
&#125;
</code></pre>
</li>
<li><p>普通构造</p>
</li>
<li><p>拷贝构造</p>
<pre><code>// 拷贝构造
Person(const Person&amp; p)&#123;
    age = p.age;
&#125;
// 将传入的p的所有属性，拷贝到我身上
</code></pre>
</li>
</ol>
<p><strong>调用方式：</strong></p>
<ol>
<li><p>在调用无参构造函数的时候不需要写括号；</p>
</li>
<li><p>匿名对象：Person(10)；当前执行结束后，系统会立即回收匿名对象，也就是调用析构函数</p>
</li>
<li><p>不要利用拷贝构造函数初始化匿名对象：编译器会认为：Person(p3) == Person p3;</p>
</li>
<li><p>隐式转换：Person p4 = 10；相当于写了 Person p4 = Person(10); // 也调用了有参构造</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Person
&#123;
public:
    // 无参构造函数
    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数调用&quot; &lt;&lt; endl;
    &#125;
    
    // 有参构造
    Person(int age)&#123;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    &#125;
    
    // 有参构造函数
    Person(string name, int age) &#123;
        cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;
    &#125;

    Person(const Person &amp; p) &#123;
        age = p.age;
        cout &lt;&lt; &quot;拷贝构造函数调用&quot; &lt;&lt; endl;
    &#125;

    // 析构函数没有参数，没有重载
    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;
    &#125;

private:
    string name;
    int age;
&#125;;

int main() &#123;
    Person person01; // 默认构造函数的调用，也就是无参构造函数的调用，在调用无参构造函数的时候不需要写括号

    Person person02(&quot;小楼&quot;, 20); // 调用有参构造函数

    Person person03(person02); // 拷贝构造函数调用
&#125; 
</code></pre>
<h4 id="4-2-3-拷贝构造函数的调用"><a href="#4-2-3-拷贝构造函数的调用" class="headerlink" title="4.2.3 拷贝构造函数的调用"></a>4.2.3 拷贝构造函数的调用</h4><ol>
<li><p>使用一个已经创建完毕的对象来初始化一个新对象</p>
</li>
<li><p>值传递的方式给函数参数传值</p>
</li>
<li><p>值方式返回局部对象</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
private:
    

public:
    int age = 0;

    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl;
    &#125;

    Person(int age) &#123;
        this-&gt;age = age;
        cout &lt;&lt; this-&gt;age;
        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;
    &#125;

    Person(const Person&amp; person) &#123; // 用const限制person,使得person不会被修改
        this-&gt;age = person.age;
        cout &lt;&lt; this-&gt;age;
        cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;
    &#125;

    ~Person() &#123;
        cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01(Person person) &#123;
    // person 是局部变量，在test函数运行结束以后，会调用析构函数
&#125;

Person test02() &#123;
    Person person;
    return person; // 返回的不是person对象，而仅仅是person的一个副本，在这个过程中，又因为创建了副本而调用了拷贝构造函数
    // 该函数结束之后，person这个局部变量也就调用析构函数而被释放
&#125;

int main() &#123;

    // 使用一个已经创建完毕的对象来初始化一个新对象
    Person person01(10);
    Person person02(person01);

    // 值传递的方式给函数参数传值,这回调用拷贝构造函数，也就是Person person(person02)
    test01(person02);

    // 值方式返回局部对象
    Person person03 = test02(); // person03是一个新的对象，这行语句是对象之间的赋值
&#125;
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="4-2-3-构造函数的调用规则"><a href="#4-2-3-构造函数的调用规则" class="headerlink" title="4.2.3 构造函数的调用规则"></a>4.2.3 构造函数的调用规则</h4><p>默认情况下，C++编译器会至少给一个类添加3个函数</p>
<ol>
<li>默认无参构造函数</li>
<li>默认无参析构函数</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>构造函数调用规则：<ul>
<li>如果用户自定义构造函数，c++就不会提供默认的无参构造器</li>
<li>如果用户自定拷贝构造函数，c++就不会提供默认的拷贝构造函数（默认的拷贝构造函数仅仅是值的复制，也就是值拷贝）</li>
</ul>
</li>
<li>如果自定义了其他构造函数，但没有定义拷贝构造函数，则会调用默认的拷贝构造函数</li>
<li>如果自定义了其他构造函数，编译器就不再提供默认无参构造函数</li>
<li>如果自定义了拷贝构造函数，编译器就不会提供默认无参构造函数</li>
</ol>
<h4 id="4-2-4-深拷贝和浅拷贝"><a href="#4-2-4-深拷贝和浅拷贝" class="headerlink" title="4.2.4 深拷贝和浅拷贝"></a>4.2.4 深拷贝和浅拷贝</h4><ol>
<li><p>浅拷贝：简单的赋值拷贝操作</p>
<pre><code>class Person &#123;

public:
    int age;
    int* high;

    Person() &#123;
        cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;
    &#125;

    Person(int age, int h) &#123;
        this-&gt;age = age;
        high = new int(h); // 用new在堆区创建变量，返回的该变量的地址，但是堆区创建的变量由程序员手动释放，释放可以在析构函数中释放
        cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;
    &#125;

    ~Person() &#123;
        // 在析构函数中释放堆区创建的变量
        if (high != NULL) &#123;
            delete high; // 手动释放堆区的变量
            high = NULL; // 防止野指针出现而指向非法的内存空间，可以将指针high设置为null，
        &#125;
        cout &lt;&lt; &quot;析构构造函数的调用&quot; &lt;&lt; endl;
    &#125;
&#125;;

// 浅拷贝
void test01() &#123;
    Person person01(10, 180);
    cout &lt;&lt; &quot;person01的年龄：&quot; &lt;&lt; person01.age &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;person01的身高为：&quot; &lt;&lt; *person01.high&lt;&lt; endl;
    Person person02(person01); 
    // 使用了默认的拷贝构造函数，这是浅拷贝，会将person01创建的堆区的变量的地址拷贝给person02
    // 切记，这是地址的拷贝，而不是地址指向的内存的存储内容的拷贝
    cout &lt;&lt; &quot;person02的年龄：&quot; &lt;&lt; person02.age &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;person02的身高为：&quot; &lt;&lt; *person02.high &lt;&lt; endl;
    // 执行析构函数的时候，先执行person02的析构函数，再执行person01的析构函数
    // person02执行析构函数之后就会把指针high指向的空间释放，因此在person01执行析构函数的时候就会使得堆区的内存重复释放，发生异常
    // 这就是浅拷贝带来的问题
&#125;
</code></pre>
</li>
<li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<pre><code>Person(const Person&amp; person) &#123;
    this-&gt;age = person.age;
    // 深拷贝的操作,在堆区重新申请内存空间，进行拷贝操作
    high = new int(*person.high);
&#125;
// 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题
</code></pre>
</li>
</ol>
<h4 id="4-2-5-初始化列表"><a href="#4-2-5-初始化列表" class="headerlink" title="4.2.5 初始化列表"></a>4.2.5 初始化列表</h4><pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
public:
    int m_a;
    int m_b;
    int m_c;

    // 初始化列表初始化属性
    Person(int a, int b, int c):m_a(a), m_b(b), m_c(c) &#123;

    &#125;
&#125;;

void test01() &#123;
    Person person(10, 20, 30);
    cout &lt;&lt; person.m_a &lt;&lt; endl;
    cout &lt;&lt; person.m_b &lt;&lt; endl;
    cout &lt;&lt; person.m_c &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-2-6-类对象作为类成员"><a href="#4-2-6-类对象作为类成员" class="headerlink" title="4.2.6 类对象作为类成员"></a>4.2.6 类对象作为类成员</h4><ol>
<li><p>一个类的成员中包含了另一个类的对象，也就是对象成员</p>
</li>
<li><p>当其他类对象作为本类成员，该对象的构造函数先执行，再调用本类的构造函数</p>
</li>
<li><p>当其他类对象作为本来成员，本类的析构函数先执行，再执行其他类对象的析构函数</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class Phone&#123;
public:
    string phone_name;

    // 无参构造函数
    Phone() &#123;
        cout &lt;&lt; &quot;Phone的无参构造函数&quot; &lt;&lt; endl;
    &#125;

    Phone(string phone_name) &#123;
        this-&gt;phone_name = phone_name;
        cout &lt;&lt; &quot;Phone的有参构造函数&quot; &lt;&lt; endl;
    &#125;

    ~Phone() &#123;
        cout &lt;&lt; &quot;Phone的析构函数&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Person &#123;
public:
    string name;
    Phone phone;

    // 初始化列表初始化属性
    Person(string name, Phone phone)&#123;
        this-&gt;name = name;
        this-&gt;phone = phone;
        cout &lt;&lt; &quot;Person的有参构造函数&quot; &lt;&lt; endl;
    &#125;

    ~Person() &#123;
        cout &lt;&lt; &quot;Person的有析构函数&quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01() &#123;
    Phone applePhone(&quot;苹果手机&quot;);
    Person person(&quot;张三&quot;, applePhone);
    cout &lt;&lt; person.name &lt;&lt; endl;
    cout &lt;&lt; person.phone.phone_name&lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-2-7-静态成员"><a href="#4-2-7-静态成员" class="headerlink" title="4.2.7 静态成员"></a>4.2.7 静态成员</h4><ol>
<li><p>静态成员函数</p>
<ul>
<li>所有的对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
<li><p>静态成员属性</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;



class Person &#123;
public:
    static int m_a; // 静态成员变量
    int m_b; // 非静态成员变量


    // 静态成员函数
    static void func01() &#123;
        m_a = 100;
        cout &lt;&lt; &quot;public权限的静态成员函数func01()&quot; &lt;&lt; endl;
        cout &lt;&lt; m_a &lt;&lt; endl; // 静态成员函数访问静态成员属性
        // cout &lt;&lt; m_b &lt;&lt; endl; // 静态成员函数不能访问非静态成员属性，因为非静态成员属性属于一个特定的类对象，静态成员函数在调用的时候若修改了非静态成员属性，这是不符合逻辑的
    &#125;
private:
    static void func02() &#123;
        m_a = 200;
        cout &lt;&lt; &quot;private权限的静态成员函数func02（）&quot; &lt;&lt; endl;
    &#125;
&#125;;

int Person::m_a = 0;  // 静态成员变量，类内声明，类外初始化

void test01() &#123;
    Person person;
    person.func01(); // 通过对象访问静态成员函数

    Person::func01(); // 通过类名访问静态成员函数

    // Person::func02(); // 类外无法访问私有权限的静态成员函数
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h3 id="4-3-C-对象模型和-this-指针"><a href="#4-3-C-对象模型和-this-指针" class="headerlink" title="4.3 C++ 对象模型和 this 指针"></a>4.3 C++ 对象模型和 this 指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><ol>
<li><p>成员变量和成员函数是分开存储的，只有非静态的成员变量才属于类的对象上</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
public:
    int m_a; // 非静态成员变量，属于类的对象上

    static int m_b; // 静态成员变量，类内声明，类外初始化,不属于类的对象上

    void func01() &#123;&#125; // 非静态成员函数也不属于类的对象上

    static void func02()&#123;&#125; // 静态成员函数也不属于类的对象上
&#125;;
int Person::m_b = 100; // 静态成员变量，类内声明，类外初始化

void test01() &#123;
    Person person;
    // 因为C++编译器会给每个空对象分配一个字节空间，为了区分空对象占内存的位置
    // 每个空对象都有独一无二的内存地址
    cout &lt;&lt; sizeof(person) &lt;&lt; endl; // 空对象占用的内存空间是 1 字节
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-3-2-this指针"><a href="#4-3-2-this指针" class="headerlink" title="4.3.2 this指针"></a>4.3.2 this指针</h4><ol>
<li><p>this指针指向被调用的成员函数所属的对象</p>
</li>
<li><p>this指针不需要定义，直接使用</p>
</li>
<li><p>this指针隐含每一个非静态成员函数内的一种指针</p>
</li>
<li><p>当形参和成员变量同名时，可用this指针来解决名称冲突</p>
</li>
<li><p>返回对象本身用this</p>
</li>
<li><p>this只能用于非静态成员函数内部，也就是必须在类内的非静态成员函数才能使用</p>
<pre><code>    // 当形参和成员变量同名时，可用this指针来解决名称冲突
    Person(int age) &#123;
        this-&gt;m_age = age; // this指针指向被调用的成员函数所属的对象，也就是this指向了对象person01
    &#125;

    // 返回的是引用，不会创建副本
    Person&amp; ageAdd(Person person) &#123;
        this-&gt;m_age = this-&gt;m_age + person.m_age;
        return *this; // this是指针，也就是被指向的对象的地址值，*this就是this指向的对象的内容
    &#125;

    // 返回的是值，会创建副本，该副本的存储地址和this指针指向的地址不是一个，但是该副本也是Person类的一个对象
    Person ageAdd(Person person) &#123;
        this-&gt;m_age = this-&gt;m_age + person.m_age;
        return *this; // this是指针，也就是被指向的对象的地址值，*this就是this指向的对象的内容
    &#125;

    // 返回的是一个地址，该地址和this指向的内存空间是一样的，当然也不会创建副本，
    Person* ageAdd(Person person) &#123;
        this-&gt;m_age = this-&gt;m_age + person.m_age;
        return this; // this是指针，也就是被指向的对象的地址值，*this就是this指向的对象的内容
    &#125;
</code></pre>
</li>
</ol>
<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><ol>
<li><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
</li>
<li><p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
public:
    int age;

    void showClassName() &#123;
        cout &lt;&lt; &quot;Person&quot; &lt;&lt; endl;
    &#125;

    void showPersonAge() &#123;
        if (this == NULL) &#123;
            cout &lt;&lt; &quot;this指针为null,以下程序将不会执行&quot; &lt;&lt; endl;
            return;
        &#125;
        cout &lt;&lt; age &lt;&lt; endl;
    &#125;
&#125;;

void test01() &#123;
    Person* person01 = NULL; // 空指针,NULL也是一个地址值
    person01-&gt;showClassName(); // 执行成功
    person01-&gt;showPersonAge(); // 执行失败，因为调用这个函数需要用到this指针指向person01，而person01是NULL,this指向了NUll指针
&#125;

int main() &#123;

    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-3-4-const修饰成员函数：常函数"><a href="#4-3-4-const修饰成员函数：常函数" class="headerlink" title="4.3.4 const修饰成员函数：常函数"></a>4.3.4 const修饰成员函数：常函数</h4><ol>
<li>成员函数后加const，我们称这个函数为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明加关键字  mutable 后，在常函数中依然可以修改</li>
<li>常对象：声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数，因为常函数中一般不会修改成员属性，除非常函数中要修改加有 mutable 修饰的成员属性</li>
</ol>
<pre><code>class Person &#123;
public:
    int age;
    mutable int m_a;

    void showPerson() const&#123;
        // 程序出错
        age = 100; // 本质是this-&gt; = age，加上const关键字后，this指针的本质是：const Person * this，那么this指针的指向和指向的内容都是不可以修改的
        
        // 特殊的变量加了mutable
        m_a = 100; // 程序正确,m_a就可以修改了
    &#125;
&#125;;

void test01() &#123;
    const Person person01; // 常对象，常对象是不可以修改的
    // person01.age = 100; // 程序出错,常对象无法修改
    person01.m_a = 100; // 程序正确，因为 m_a 加了关键字 mutable，该常对象的这个属性就可以修改了

    person01.showPerson(); // 程序正确，常对象只能调用常函数，若调用普通函数可能修改常对象的属性，这是不允许的
&#125;
</code></pre>
<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>友元的目的就是让一个函数或者类访问另一个类中私有成员</p>
<p>关键字：friend</p>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

// 建筑类
class Building &#123;

    // 将test01在类中声明为该类的友元函数，test01()就可以访问该类的私有成员了
    friend void test01(Building&amp; building);
    
    // 将GoodGay设置为友元类
    friend class GoodGay;
    
    // 将GoodGay中的visit()函数单独设置为该类的友元
    friend void GoodGay::visit();

public:
    Building() &#123;
        m_SittingRoom = &quot;客厅&quot;;
        m_BedRoom = &quot;卧室&quot;;
    &#125;

    string m_SittingRoom;

private:
    string m_BedRoom;
&#125;;

// 全局函数,想访问类的私有成员和公有成员
void test01(Building&amp; building) &#123;
    // 访问公有属性
    cout &lt;&lt; building.m_SittingRoom &lt;&lt; endl;

    // 访问私有属性
    cout &lt;&lt; building.m_BedRoom &lt;&lt; endl; // 出错，不可以访问私有属性

    // 在类中声明test01()为友元函数，那么test01()就可以访问私有属性了
&#125;

int main() &#123;
    Building building;
    test01(building);
&#125;
</code></pre>
<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><pre><code>class  GoodGay &#123;
public:
    Building* building = new Building; // 要将这个类对象的属性初始化

    void visit() &#123;

        // 访问Building中的公有和私有属性
        cout &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; // 访问公有属性，这是可以的
        cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; // 友元类访问私有属性，
    &#125;
&#125;;
</code></pre>
<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><p>将类的特定的成员函数设置为另一个类的友元</p>
<p>friend void 类名::函数名();</p>
<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>进行类对象的自定义运算方式</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>实现两个自定义的数据类型相加的运算</p>
<p>关键字：operator+</p>
<p>参数不同是可以重载的</p>
<p>不要滥用运算符重载</p>
<p>对于内置的基本数据类型的表达式的运算符是不可以改变的</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;

public:
    int m_a;
    int m_b;

    // 成员函数重载加号运算符
    /*Person operator+(Person person) &#123;
        Person temp;
        temp.m_a = this-&gt;m_a + person.m_a;
        temp.m_b = this-&gt;m_b + person.m_b;
        return temp;
    &#125;*/

&#125;;

Person operator+(Person person01, Person person02) &#123;
    Person temp;
    temp.m_a = person01.m_a + person02.m_a;
    temp.m_b = person01.m_b + person02.m_b;
    return temp;
&#125;

void test01() &#123;
    Person person01;
    person01.m_a = 10;
    person01.m_b = 10;

    Person person02;
    person02.m_a = 20;
    person02.m_b = 20;

    Person person03;
    person03 = person01 + person02; // 其本质就是 person03 = person01.operator+(person02);
    
    cout &lt;&lt; person03.m_a &lt;&lt; endl;
    cout &lt;&lt; person03.m_b &lt;&lt; endl;
&#125;

void test02() &#123;
    Person person01;
    person01.m_a = 10;
    person01.m_b = 10;

    Person person02;
    person02.m_a = 20;
    person02.m_b = 20;

    Person person03;
    
    person03 = person01 + person02; // 其本质就是 person03 = operator+(person01, person02); 调用的是全局运算符重载函数

    cout &lt;&lt; person03.m_a &lt;&lt; endl;
    cout &lt;&lt; person03.m_b &lt;&lt; endl;

&#125;

int main() &#123;
    //test01();
    test02();

&#125;
</code></pre>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>左移运算符配合友元可以将自定义数据类型直接输出</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;

public:
    int m_a;
    int m_b;

    // 通常不会利用成员函数，符重载左移运算符 &quot;&lt;&lt;&quot;
    // 因为无法实现cout在左侧，不好实现
    // 但是可以使用全局函数来实现该运算符重载

&#125;;

// 只能利用全局函数重载左移运算符
// cout是 ostream 的对象，且只能有一个对象，不能创建副本，因此用引用指向同一块内存
// 不需要返回值
ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person person) &#123; // 本质调用：operator&lt;&lt;(cout, p),简化cout&lt;&lt;person;
    cout &lt;&lt; person.m_a &lt;&lt; endl;
    cout &lt;&lt; person.m_b &lt;&lt; endl;
    return cout;
&#125;

void test01() &#123;
    Person person01;
    person01.m_a = 10;
    person01.m_b = 10;

    cout &lt;&lt; person01 &lt;&lt; endl;
    // 使用一次左移运算符就返回一次cout对象

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>通过重载递增运算符，可以实现自定义数据类型的自增或自减运算</p>
<p>前置递增返回的是引用</p>
<p>后置递增返回的是值</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person person);
public:
    
    Person(int a) &#123;
        m_a = a;
    &#125;
    
    // 重载前置++运算符
    Person&amp; operator++() &#123;
        ++m_a;
        return *this;
    &#125;

    // 重载后置++运算符
    Person operator++(int) &#123; // 用int占位，用于区分这是后置递增
        Person temp = *this;
        m_a++;
        return temp; // 返回的是值，是一个副本，该副本记录了未自增时的数据
    &#125;

private:
    int m_a;
&#125;;

ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person person) &#123;
    cout &lt;&lt; person.m_a &lt;&lt; endl;
    return cout;
&#125;

void test01() &#123;
    Person person01(10);
    cout &lt;&lt; ++person01 &lt;&lt; endl; // 实现了了自定义类的自增运算

    cout &lt;&lt; person01++ &lt;&lt; endl;
    cout &lt;&lt; person01 &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>进行自定义对象的赋值运算</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;

public:
    Person(int age) &#123;
        m_age = new int(age);
    &#125;

    ~Person() &#123;
        if (m_age != NULL) &#123;
            delete m_age;
            m_age = NULL; // 防止m_age指向非法的内存空间
        &#125;
    &#125;

    // 重载赋值运算符
    // 链式编程，返回类型为Person
    Person&amp; operator=(Person&amp; person) &#123;
        // 编译器提供的是浅拷贝
        // 因此在重载赋值运算符的时候，进行深拷贝
        // 首席判断属性是否在堆区，若在堆区就要释放干净，然后再进行深拷贝
        if (m_age != NULL) &#123;
            delete m_age;
            m_age = NULL;
        &#125;
        m_age = new int(*person.m_age);
        return *this;
    &#125;

    int* m_age;
&#125;;

void test01() &#123;
    Person person01(10);

    Person person02(20);

    Person person03(30);

    person03 = person02 = person01;  // 赋值运算符是可以进行对象的拷贝的，会调用默认的拷贝构造函数，就行对象属性值的拷贝,这是浅拷贝，有风险
    // person01和person02中的属性共同指向了一块内存空间，若person01执行了析构函数，释放了这块内存空间
    // 当person02调用析构函数的时候，就无法释放已经被person01释放的内存，而报错
    // 堆区的内存重复释放，程序出错
    // 解决方法：
    // 深拷贝替换浅拷贝，用户自己定义拷贝构造函数

    cout &lt;&lt; *person01.m_age &lt;&lt; endl;
    cout &lt;&lt; *person02.m_age &lt;&lt; endl;
    cout &lt;&lt; *person03.m_age &lt;&lt; endl;

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p>可以让两个自定义类型的对象就行比较大小</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
public:
    Person(int age) &#123;
        m_age = age;
    &#125;

    bool operator==(Person person) &#123;
        if (m_age == person.m_age) &#123;
            return true;
        &#125;
        return false;
    &#125;

    int m_age;
&#125;;

void test01() &#123;
    Person person01(10);
    Person person02(10);

    cout &lt;&lt; (person01 == person02) &lt;&lt; endl;

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><p>函数调用运算符()也可以重载</p>
<p>由于重载后使用的方式非常像函数调用，因此可以称为仿函数</p>
<p>仿函数没有固定写法</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Person &#123;
public:

    void operator()(int a) &#123;
        cout &lt;&lt; a &lt;&lt; endl;
    &#125;

&#125;;

void test01() &#123;
    Person person;
    person(10); // 由于和函数调用非常相似，就称为仿函数
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h3><p>抽象、共性、特性</p>
<p>代码复用</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>子类也称为派生类，父类也称为基类</p>
<p>class 子类名 ：继承方式 父类名{</p>
<p>}</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p><strong>公有继承：</strong></p>
<ol>
<li>父类中的私有属性不可以继承，其他权限的属性都可以由子类继承，且父类中的这些属性在子类中属性的权限不变</li>
<li>父类中保护成员在子类中依然是保护权限，子类可以访问，该成员在子类中依然是保护权限，保护权限类外不可以访问</li>
<li>父类中私有成员在子类中不可以访问</li>
</ol>
<p><strong>保护继承：</strong></p>
<ol>
<li>父类中的公有成员、保护成员在子类中变为保护成员，保护成员在类外访问不到</li>
<li>父类中的私有成员，子类中不可以访问</li>
</ol>
<p><strong>私有继承：</strong></p>
<ol>
<li>父类中的公有成员、保护成员在子类中称为私有成员，私有成员在类外无法访问</li>
<li>父类中的私有成员，在子类中不可以访问</li>
</ol>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220413170510476.png" alt="image-20220413170510476"></p>
<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><ol>
<li>父类中的所有非静态成员属性都会被子类继承</li>
<li>父类中私有成员属性被编译器隐藏，因此无法在子类访问，但是确实被继承了</li>
</ol>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><ol>
<li>子类继承父类后，当创建子类对象，也会调用父类的构造函数</li>
<li>创建子类对象后，也会创建父类对象</li>
<li>先调用父类的构造函数，再调用子类的构造函数</li>
<li>先调用子类的析构函数，再调用父类的析构函数</li>
</ol>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><ol>
<li>子类对象加父类作用域可以访问父类的同名成员</li>
<li>访问子类的同名成员，直接访问即可</li>
<li>访问父类的同名成员，指定父类的作用域操作即可：子类对象.父类::欲访问的父类中的属性。</li>
<li>如果子类中出现和父类同名的函数，子类会隐藏父类中所有同名的函数，如果想访问父类的同名函数，就需要限定作用域：子类对象.父类名::欲访问的父类中的函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理"><a href="#4-6-6-继承同名静态成员处理" class="headerlink" title="4.6.6 继承同名静态成员处理"></a>4.6.6 继承同名静态成员处理</h4><ol>
<li><p>静态成员和非静态成员出现同名，处理方式一致</p>
</li>
<li><p><strong>切记：</strong>静态属性要在类内声明，类外初始化</p>
</li>
<li><p>父类中出现了与子类同名的静态函数，父类的同名静态函数会被隐藏，必须通过父类的作用域才能访问</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Base &#123;
public:
    static int m_a; // 类内静态属性声明
&#125;;
int Base::m_a = 100; // 类外静态属性初始化


class Son : public Base&#123;
public:
    static int m_a; // 覆盖父类同名静态属性
&#125;;
int Son::m_a = 200;

void test01() &#123;
    // 1,创建对象访问静态属性
    Son son;
    cout &lt;&lt; &quot;son的静态属性值&quot; &lt;&lt; son.m_a &lt;&lt; endl;
    cout &lt;&lt; &quot;Bese的静态属性值&quot; &lt;&lt; son.Base::m_a &lt;&lt; endl;

    // 2，通过类名访问静态同名属性
    cout &lt;&lt; &quot;Son的静态属性值&quot; &lt;&lt; Son::m_a &lt;&lt; endl;
    // Son要通过类名访问父类作用域下的静态属性
    cout &lt;&lt; &quot;Base的静态属性值&quot; &lt;&lt; Son::Base::m_a &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><ol>
<li><p>C++允许一个类继承多个类</p>
</li>
<li><p>语法：</p>
<pre><code>class 子类：继承方式 父类1，继承方式：父类2...
</code></pre>
</li>
<li><p>多继承可能会引发父类中同名成员的出现，需要加作用域区分</p>
</li>
<li><p>C++实际开发中不建议使用多继承</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Base01 &#123;
public:
    int m_a;

    Base01() &#123;
        m_a = 100;
    &#125;
&#125;;

class Base02 &#123;
public:
    int m_a;
    Base02() &#123;
        m_a = 200;
    &#125;
&#125;;

class Son : public Base01, public Base02 &#123;
public:
    int m_c;
    int m_d;
    Son() &#123;
        m_c = 300;
        m_d = 400;
    &#125;
&#125;;

void test01() &#123;
    Son son;
    // 父类出现同名的属性，要加作用域进行访问
    cout &lt;&lt; son.Base01::m_a &lt;&lt; endl; 
    cout &lt;&lt; son.Base02::m_a &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p>两个派生类继承自同一个类</p>
<p>又有某个类同时继承了这两个派生类</p>
<p>这种继承称为菱形继承，也是钻石继承</p>
<p>两个父类拥有相同的属性时可以加以作用域区分</p>
<p>![QQ图片20220414102242](H:\新建文件夹 (6)\QQ图片20220414102242.png)</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Animal &#123;
public:
    int m_a;
&#125;;

// 利用虚继承解决菱形继承的问题
// 继承之前，加上关键字 virtual 变为虚继承
// Animal 类称为 虚基类
class Sheep : virtual public Animal &#123;

&#125;;

// 利用虚继承解决菱形继承的问题
// 继承之前，加上关键字 virtual 变为虚继承
// Animal 类称为 虚基类
class Tuo : virtual public Animal &#123;

&#125;;

class SheepTuo : public Sheep, public Tuo &#123;

&#125;;

void test01() &#123;
    SheepTuo sheepTuo;
    sheepTuo.Sheep::m_a = 30;
    sheepTuo.Tuo::m_a = 20;
    // 当发生虚继承之后，同名继承的属性就只有一个，类似于共享的一份数据
    // 因此 sheepTuo.Sheep::m_a = 30;之后sheepTuo.Tuo::m_a = 20;就将数据修改为了20
    // 而且sheepTuo.m_a 可以不加作用域进行访问，不会出现数据不明确的情况
    // 这是为什么？
    // 因为：在底层，第三层的类会直接找到第一层的公有的属性，进而继承第一层的属性（该属性同名出现在第二层继承的两个类中）
    // 第三层找到第一层的属性（该属性被第二层的多个类继承）,是由第三层通过第二层的指针找到的第一层的共有同名属性的
    cout &lt;&lt; sheepTuo.Sheep::m_a &lt;&lt; endl;
    cout &lt;&lt; sheepTuo.Tuo::m_a &lt;&lt; endl;
    cout &lt;&lt; sheepTuo.m_a &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<p>菱形继承使用较少</p>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p>父类的引用可以指向子类的对象，不需要类型转换</p>
<p><strong>静态多态：</strong>函数重载 和 运算符重载属于静态多态，复用函数名</p>
<p><strong>动态多态：</strong>派生类和虚函数实现运行时多态</p>
<p><strong>静态多态和动态多态的区别：</strong></p>
<p>静态多态的函数地址早绑定——编译阶段确定函数地址</p>
<p>动态多态的函数地址晚绑定——运行阶段确定函数地址</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

class Animal &#123;
public:
    virtual void speak() &#123; // 要实现子类对象的动态绑定，就需要将父类的函数设置为虚函数
        cout &lt;&lt; &quot;动物在叫&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Cat :public Animal &#123;
public:
    void speak() &#123; // 子类重写父类的虚函数，重写的返回值类型，函数名、参数列表都要与父类虚函数一致
        cout &lt;&lt; &quot;猫在说话&quot; &lt;&lt; endl;
    &#125;
&#125;;

void doSpeak(Animal&amp; animal) &#123; // 父类的指针或者引用来指向子类的对象，来实现动态绑定
                            // 这是因为引用或指针指向了一块子类对象的空间，这就调用了子类对象的函数
    animal.speak();
&#125;

void test01() &#123;
    Cat cat;
    doSpeak(cat);
&#125;

int main() &#123;
    test01();
&#125;

// 输出结果：动物在叫
// 因为：执行说话的函数地址早绑定（在编译阶段确定函数地址）
// 如果想执行让猫说话，这个函数的地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定
// 将Animal类中的speak()函数设置为虚函数，就可以进行晚绑定，也就是动态多态，动态绑定，如下程序：
class Animal &#123;
public:
     virtual void speak() &#123;
        cout &lt;&lt; &quot;动物在叫&quot; &lt;&lt; endl;
    &#125;
&#125;;
// 进行修改以后，输出结果就是：猫在说话
</code></pre>
<p><strong>动态多态：</strong></p>
<ul>
<li><p>得有继承关系</p>
</li>
<li><p>子类要重写父类的虚函数，重写：函数返回值类型，函数名，参数列表都得完全相同</p>
</li>
<li><p>父类的指针或者引用来指向子类的对象</p>
</li>
</ul>
<p><strong>动态原理：</strong></p>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220415094100054.png" alt="image-20220415094100054"></p>
<p><strong>多态的优点：</strong></p>
<ul>
<li><p>代码组织和结构清晰</p>
</li>
<li><p>可读性强</p>
</li>
<li><p>利于前后期扩展维护</p>
</li>
</ul>
<h4 id="4-7-2-多态案例一—计算器类"><a href="#4-7-2-多态案例一—计算器类" class="headerlink" title="4.7.2 多态案例一—计算器类"></a>4.7.2 多态案例一—计算器类</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

class AbstractCalculator &#123;

public:
    int m_a;
    int m_b;

    virtual int getResult() &#123;
        return 0;
    &#125;
    
&#125;;

// 加法计算
class AddCalculator : public AbstractCalculator &#123;
    
    // 重写父类的虚函数，这样就可以实现动态绑定
    int getResult() &#123;
        return m_a + m_b;
    &#125;

&#125;;

// 减法计算
class SubCalculator : public AbstractCalculator &#123;

    // 重写父类的虚函数，这样就可以实现动态绑定
    int getResult() &#123;
        return m_a - m_b;
    &#125;

&#125;;

void test01() &#123;

    // 父类的指针或引用指向之类的对象，实现动态绑定的使用
    AbstractCalculator* absCal = new AddCalculator;
    absCal-&gt;m_a = 10;
    absCal-&gt;m_b = 10;
    cout &lt;&lt; absCal-&gt;m_a &lt;&lt; endl;
    cout &lt;&lt; absCal-&gt;m_b &lt;&lt; endl;
    cout &lt;&lt; absCal-&gt;getResult() &lt;&lt; endl;

    // 手动释放堆区创建的 AddCalculator 对象
    delete absCal; // 释放的是absCal指向是堆区的空间的内容，absCal指针本身并没有销毁，可以指向别的对象
    absCal = NULL; // 因此要将abcCal指向NUll,防止该指针（野指针）指向不该指向的地方

    SubCalculator sub;
    absCal = &amp;sub; // absCal指向了SubCalculator对象，改变了指向
    absCal-&gt;m_a = 20;
    absCal-&gt;m_b = 20;
    cout &lt;&lt; absCal-&gt;m_a &lt;&lt; endl;
    cout &lt;&lt; absCal-&gt;m_b &lt;&lt; endl;
    cout &lt;&lt; absCal-&gt;getResult() &lt;&lt; endl;
    
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><ol>
<li><p>在父类中实现虚函数是无意义的，因此将父类的虚函数设置为纯虚函数</p>
</li>
<li><p>语法：virtual 返回值类型 函数名 （形参列表） = 0；</p>
</li>
<li><p>当类中有了纯虚函数，这个类也就称为抽象类</p>
</li>
<li><p>抽象类的特点：无法实例化对象、子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
</li>
<li><pre><code>#include&lt;iostream&gt;
using namespace std;

// 将基类设置为抽象类（只要有一个纯虚函数就被称为抽象类）
// 抽象类是无法实例化对象的
// 抽象类的子类必须要重写父类的纯虚函数，否则子类也属于抽象类
class Base &#123;
public:
    // 纯虚函数
    virtual void func01() = 0;

    void func02() &#123;
        cout &lt;&lt; &quot;父类的func02函数&quot; &lt;&lt; endl;
    &#125;;
&#125;;

class Son :public Base &#123;

    // 重写父类的纯虚函数，否则依旧是抽象类
    void func01() &#123;
        cout &lt;&lt; &quot;重写了父类的纯虚函数&quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01() &#123;
    Son son;
    Base* base = &amp;son;
    base-&gt;func01();
    base-&gt;func02();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-7-4-虚析构和纯虚析构"><a href="#4-7-4-虚析构和纯虚析构" class="headerlink" title="4.7.4 虚析构和纯虚析构"></a>4.7.4 虚析构和纯虚析构</h4><ol>
<li><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时就无法调用到子类的析构函数</p>
</li>
<li><p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
</li>
<li><p>虚析构和纯虚析构的共性：</p>
<ul>
<li>可以解决父类指针释放子类的对象</li>
<li>都需要具体的函数实现</li>
</ul>
</li>
<li><p>虚析构和纯虚析构的区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
</li>
<li><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;iostream&gt;

class Animal &#123;
public:
    virtual void speak() = 0;
    Animal() &#123;
        cout &lt;&lt; &quot;执行了父类的构造函数&quot; &lt;&lt; endl;
    &#125;
    /*
    virtual ~Animal() &#123; // 将父类中的析构函数改为虚析构函数，在执行父类的析构函数时也会调用子类的析构函数
        cout &lt;&lt; &quot;执行了父类的析构函数&quot; &lt;&lt; endl;
    &#125;
    */

    virtual ~Animal() = 0; // 纯虚析构在类内声明，在类外实现
    // 有了纯虚析构函数，该类也属于抽象类，无法实例化对象
    // 因为父类中也有可能在堆区创建的属性，因此也需要被释放，也得实现析构函数，因此纯虚析构在类内只是声明，在类外实现释放父类的堆区属性
&#125;;

// 在类外实现纯虚析构
Animal:: ~Animal() &#123;
    cout &lt;&lt; &quot;父类的纯虚析构&quot; &lt;&lt; endl;
&#125;

class Cat : public Animal &#123;
public:
    string* cat_name;

    Cat(string name) &#123;
        cout &lt;&lt; &quot;执行了子类的构造函数&quot; &lt;&lt; endl;
        cat_name = new string(name); // cat_name 指向了堆区的数据
    &#125;

    void speak() &#123;
        cout &lt;&lt; *cat_name &lt;&lt; &quot;猫在叫&quot; &lt;&lt; endl;
    &#125;

    ~Cat() &#123;
        if (cat_name != NULL) &#123;
            delete cat_name;
            cat_name = NULL;
            cout &lt;&lt; &quot;执行了子类的析构函数&quot; &lt;&lt; endl;
        &#125;
    &#125;
&#125;;

void test01() &#123;
    
    Animal* animal = new Cat(&quot;tom&quot;);
    animal-&gt;speak();
    // 父类指针在析构的时候，不会调用子类的析构函数，导致子类如果有堆区的属性就无法释放，造成内存泄露
    delete animal;
    animal = NULL;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<p>如果子类中没有堆区数据，可以在父类中不写纯虚构或纯虚析构</p>
<h2 id="第五章-文件操作"><a href="#第五章-文件操作" class="headerlink" title="第五章 文件操作"></a>第五章 文件操作</h2><ol>
<li><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束就会被释放</p>
</li>
<li><p>通过文件可以将数据持久化</p>
</li>
<li><p>C++对文件操作需要包含头文件<fstream></p>
</li>
<li><p>文件分为：文本文件和二进制文件</p>
</li>
<li><p>文本文件：文件以文本的ASCII码形式存储在计算机中，编码格式为 ANSI，其他格式的文件无法进行读写</p>
</li>
<li><p>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能能直接读懂</p>
</li>
</ol>
<p><strong>操作文件的三大类：</strong></p>
<ul>
<li>ofstream：写操作</li>
<li>ifstream：读操作</li>
<li>fstream：读写操作，在进行读写操作时，读操作和写操作分开写，分别打开和关闭fstream流</li>
</ul>
<h3 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h3><h4 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h4><ol>
<li>包含头文件：#include<fstream></li>
<li>创建对象流：ofstream ofs；</li>
<li>打开文件：ofs.open(“文件的路径”, 打开方式);</li>
<li>写数据：ofs&lt;&lt;“写入的数据”&lt;&lt;endl;</li>
<li>关闭文件：ofs.close()；</li>
</ol>
<p><strong>文件的打开方式：</strong></p>
<ul>
<li>ios::in 为读文件而打开文件</li>
<li>ios::out 为写文件而打开文件</li>
<li>ios::ate 初始位置：文件尾</li>
<li>ios::app 追加方式写文件</li>
<li>ios::trunc 如果文件存在先删除，再创建</li>
<li>ios::binary 二进制方式</li>
<li><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220502181325694.png" alt="image-20220502181325694"></li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li><p>文件打开方式可以配合使用，利用 | 操作符，例如：ios::binary | ios::out 用二进制方式写文件</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;

int main() &#123;
    ofstream ofs; // 写文件
    ofs.open(&quot;test.txt&quot;, ios::out); // 若不指定路径就会把创建的文件放到该项目的目录下
    ofs &lt;&lt; &quot;写入了C++&quot; &lt;&lt; endl;
    ofs &lt;&lt; &quot;写入了C++&quot; &lt;&lt; endl;
    ofs &lt;&lt; &quot;写入了C++&quot; &lt;&lt; endl;
    ofs.close(); // 关闭输出流
&#125;
</code></pre>
</li>
</ol>
<h4 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h4><ol>
<li><p>包含头文件#include<fstream></p>
</li>
<li><p>创建流对象ifstream ifs;</p>
</li>
<li><p>打开文件，并判断是否打开成功：ifs.open(“文件路径”, 打开方式);</p>
</li>
<li><p>读数据</p>
</li>
<li><p>关闭流</p>
<pre><code>// 读文件
    ifstream ifs;
    ifs.open(&quot;F:\\VisualStudioC++Study\\C++核心学习\\test.txt&quot;, ios::in); // 指定文件路径读文件
    if (!ifs.is_open()) &#123;
        cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;
        return 0;
    &#125;

    // 读数据
    // 第一种：
    char buf01[1024] = &#123;0&#125;;
    while (ifs&gt;&gt;buf01)
    &#123;
        cout &lt;&lt; buf01 &lt;&lt; endl;
    &#125;

    // 第二种
    char buf02[1024] = &#123; 0 &#125;;
    while (ifs.getline(buf02, sizeof(buf02))) &#123;
        cout &lt;&lt; buf02 &lt;&lt; endl;
    &#125;

    // 第三种
    string buf03;
    while (getline(ifs, buf03))
    &#123;
        cout &lt;&lt; buf03 &lt;&lt; endl;
    &#125;

    // 第四种
    char c;
    while ((c = ifs.get()) != EOF)
    &#123;
        cout &lt;&lt; c;
    &#125;

    ifs.close();
</code></pre>
</li>
</ol>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>打开方式要制定为 ios::binary</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要是利用流对象调用成员函数 write</p>
<p>函数原型：</p>
<pre><code>ostream&amp; write(const char * buffer, int len);
// 字符指针buffer指向内存中一段存储空间
// len 是读写的字节数
</code></pre>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;fstream&gt;

class Person &#123;

public:
    char m_name[64];
    int m_age; 
&#125;;

int main() &#123;
    // 创建流对象
    ofstream ofs;
    // 打开文件
    ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);
    // 写文件
    Person person = &#123;&quot;张三&quot;, 19&#125;;
    ofs.write((const char*)&amp; person, sizeof(person));
    // 关闭文件
    ofs.close();
&#125;
</code></pre>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：</p>
<pre><code>ifstream&amp; read(char* buffer, int len);
// 字符指针buffer指向内存中的一段存储空间
// len是读写的字节数
</code></pre>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;fstream&gt;

class Person &#123;

public:
    char m_name[64];
    int m_age; 
&#125;;

int main() &#123;
    // 创建流对象，并指定文件路径，和读取方式
    ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);
    // 判断文件是否打开
    if (!(ifs.is_open())) &#123;
        cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;
        return 0;
    &#125;
    // 读取文件到person对象中
    Person person;
    ifs.read((char *)&amp;person, sizeof(Person));

    // 输出person对象的数据
    cout &lt;&lt; person.m_age &lt;&lt; endl;
    cout &lt;&lt; person.m_name &lt;&lt; endl;
    // 关闭流
    ifs.close();
&#125;
</code></pre>
<h1 id="C-提高阶段"><a href="#C-提高阶段" class="headerlink" title="C++提高阶段"></a>C++提高阶段</h1><p>主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用</p>
<h2 id="第一章-模板"><a href="#第一章-模板" class="headerlink" title="第一章 模板"></a>第一章 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><ol>
<li>模板就是建立通用的模具，大大提高复用性</li>
<li>特点：<ul>
<li>模板不可以直接使用，它是一个框架</li>
<li>模板的通用性不是万能的</li>
</ul>
</li>
</ol>
<h3 id="1-2-函数的模板"><a href="#1-2-函数的模板" class="headerlink" title="1.2 函数的模板"></a>1.2 函数的模板</h3><h4 id="1-2-1-函数模板概念"><a href="#1-2-1-函数模板概念" class="headerlink" title="1.2.1 函数模板概念"></a>1.2.1 函数模板概念</h4><ol>
<li><p>C++另一种编程思想就是泛型编程，主要利用的技术就是模板</p>
</li>
<li><p>C++提供两种模板机制：函数模板和类模板</p>
</li>
<li><p>函数模板的作用：建立一个通用函数，其返回值类型和参数类型可以不具体指定，用一个虚拟的类型来代表，也就是类型参数化</p>
</li>
<li><p>语法：</p>
<pre><code>template&lt;typename T&gt;
函数声明或定义

// template 声明创建模板
// typename 表明后面的符号是一种数据类型，可以用class代替
// T 通用的数据类型，名称可以替换，通常为大写字母
</code></pre>
</li>
<li><pre><code>#include&lt;iostream&gt;
using namespace std;

// 函数模板
// 两个整型交换的函数
void swapInt(int &amp;a, int &amp;b) &#123;
    int temp = a;
    a = b;
    b = temp;
&#125;

// 交换两个浮点型
void swapDouble(double &amp;a, double &amp;b) &#123;
    double temp = a;
    a = b;
    b = temp;
&#125;

// 设置一个交换数据的函数模板
template&lt;typename T&gt; // T 表示一个通用的数据类型
void mySwap(T&amp; a, T&amp; b) &#123;
    T temp = a;
    a = b;
    b = temp;
&#125;

void test01() &#123;
    int a = 10;
    int b = 20;
    swapInt(a, b);
    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; b &lt;&lt; endl;

    double c = 1.1;
    double d = 3.2;
    swapDouble(c, d);
    cout &lt;&lt; c &lt;&lt; endl;
    cout &lt;&lt; d &lt;&lt; endl;
    
    // 用模板函数交换数字
    // 1. 自动类型转换
    mySwap(a, b);
    cout &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; b &lt;&lt; endl;

    // 2. 指定类型交换
    mySwap&lt;double&gt;(c, d);
    cout &lt;&lt; c &lt;&lt; endl;
    cout &lt;&lt; d &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
<li><p>函数模板的注意事项：</p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T，才可以使用</p>
</li>
<li><p>模板必须要确定出 T 的数据类型才可以使用</p>
<pre><code>tempalate&lt;class T&gt; //typename 可以被替换为 class 作用都是一样的

template&lt;class T&gt;
void func() &#123;
    cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;
&#125;
void test02() &#123;
    func&lt;int&gt;(); // 必须要指定 T 的数据类型才可以使用
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong>7. 案例：</strong>利用模板封装一个排序函数，实现不同数据类型的数据的排序，从大到小，选择排序</p>
<p>对 char 数组，和 int 数组进行排序</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 运用模板提供通用的选择排序模板函数
template&lt;typename T&gt;
void selectSort(T arr[], int length) &#123;
    int max;
    for (int i = 0; i &lt; length; i++)
    &#123;
        max = i;
        // 取得每一轮比较的最大值的下标
        for (int j = i + 1; j &lt; length; j++)
        &#123;
            if (arr[max] &lt; arr[j])
            &#123;
                max = j;
            &#125;
        &#125;
        if (max != i) // 说明max发生了改变,在每一轮比较后，发现了更大的值
        &#123;
            // 交换小标指向的值
            T temp = arr[max];
            arr[max] = arr[i];
            arr[i] = temp;
        &#125;
    &#125;

    // 排好序以后，将数组输出
    for (int i = 0; i &lt; length; i++)
    &#123;
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    &#125;
&#125;

// 对字符数组进行排序
void test01() &#123;
    char ch[] = &quot;abcdef&quot;; // 在c++中可以用 char 定义字符数组
    int chLength = sizeof(ch) / sizeof(char);
    selectSort(ch, chLength); // 自动进行类型判断
&#125;

// 对整型数组进行排序
void test02() &#123;
    int nums[] = &#123;5, 4, 3, 2, 1&#125;;
    int length = sizeof(nums) / sizeof(int);
    selectSort&lt;int&gt;(nums, length);
&#125;

int main() &#123;
    test01();
    cout &lt;&lt; endl;
    test02();
&#125;
</code></pre>
<h4 id="1-2-2-函数模板与普通函数的区别"><a href="#1-2-2-函数模板与普通函数的区别" class="headerlink" title="1.2.2 函数模板与普通函数的区别"></a>1.2.2 函数模板与普通函数的区别</h4><ul>
<li><p>普通函数调用时可以发生自动类型转换（隐式类型转换）</p>
</li>
<li><p>函数模板调用时，如果利用自动类型推导，不可以发生隐式类型转换</p>
</li>
<li><p>函数模板调用时，用显示指定类型，可以发生隐式类型转换</p>
</li>
<li><p>建议使用指定类型调用函数模板，防止出错</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 普通函数
void addNum01(int a, int b) &#123;
    cout &lt;&lt; a + b &lt;&lt; endl;
&#125;

void test01() &#123;
    int a = 10;
    int b = 20;
    char c = &#39;c&#39;;
    addNum01(a, b);
    addNum01(a, c); // 调用了普通函数，发生了隐式类型转换 char -&gt; int
&#125;

// 模板函数
template&lt;typename T&gt;
void addNum02(T a, T b) &#123;
    cout &lt;&lt; a + b &lt;&lt; endl;
&#125;

void test02() &#123;
    int a = 10;
    int b = 20;
    char c = &#39;c&#39;;
    // 自动类型推导，不会发生隐式类型转换
    // addNum02(a, c); // 这就会出错，无法指定一致的类型 T

    // 用显示指定类型的方法调用函数模板，会发生隐式类型转换
    addNum02&lt;int&gt;(a, c); //  char -&gt; int
&#125;

int main() &#123;
    test01();
    test02();
&#125;
</code></pre>
</li>
</ul>
<h4 id="1-2-3-普通函数与函数模板调用规则"><a href="#1-2-3-普通函数与函数模板调用规则" class="headerlink" title="1.2.3 普通函数与函数模板调用规则"></a>1.2.3 普通函数与函数模板调用规则</h4><ul>
<li><p>如果函数模板和普通函数都可以使用，则优先调用普通函数</p>
</li>
<li><p>若只想调用函数模板，则可以通过空模板参数列表来强制调用函数模板</p>
</li>
<li><p>函数模板可以重载</p>
</li>
<li><p>如果函数模板可以产生更好的匹配优先调用函数模板</p>
</li>
<li><p>建议：若可以写模板就不要再用普通函数了</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 普通函数
void myPrint(int a, int b) &#123;
    cout &lt;&lt; &quot;调用普通函数&quot; &lt;&lt; endl;
&#125;

// 模板函数
template&lt;typename T&gt;
void myPrint(T a, T b) &#123;
    cout &lt;&lt; &quot;调用模板函数&quot; &lt;&lt; endl;
&#125;

// 重载函数模板
template&lt;typename T&gt;
void myPrint(T a, T b, T c) &#123;
    cout &lt;&lt; &quot;重载模板函数&quot; &lt;&lt; endl;
&#125;

void test01() &#123;
    myPrint(10, 20); // 优先调用普通函数
    
&#125;

void test02() &#123;
    // 通过空模板参数列表强制调用函数模板
    myPrint&lt;&gt;(10, 20);
    myPrint&lt;int&gt;(10, 20); // 通过模板的参数列表强制调用函数模板
&#125;

void test03() &#123;
    //函数模板重载
    myPrint&lt;&gt;(10, 20, 30);
&#125;

void test04() &#123;
    myPrint(&#39;a&#39;, &#39;b&#39;); // 优先调用了模板，因为不需要进行隐式转换，调用模板产生了更好的匹配
&#125;

int main() &#123;
    test01();
    test02();
    test03();
    test04();
&#125;
</code></pre>
</li>
</ul>
<h4 id="1-2-4-模板的局限性"><a href="#1-2-4-模板的局限性" class="headerlink" title="1.2.4 模板的局限性"></a>1.2.4 模板的局限性</h4><ul>
<li><p>模板的通用性不是万能的，有些特定的数据类型，需要用具体化的方式做特殊实现</p>
</li>
<li><p>如果函数模板中，传入了数组、自定义类型等数据，就无法正常运行了</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

class Person &#123;
public:
    int m_age;
    string m_name;

    Person(int age, string name) &#123;
        this-&gt;m_age = age;
        this-&gt;m_name = name;
    &#125;

&#125;;


// 对比两个数是否相等
template&lt;typename T&gt;
void myCompare(T a, T b) &#123;
    if (a == b)
    &#123;
        cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
    &#125;
&#125;

// 利用具体化Perosn的版本实现代码，具体化优先调用
template&lt;&gt; void myCompare(Person a, Person b) &#123;
    if (a.m_age == b.m_age &amp;&amp; a.m_name == b.m_name)
    &#123;
        cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;
    &#125;
&#125;

// 基本类型比较
void test01() &#123;
    myCompare(10, 10);
&#125;

// 自定义类型比较
// 方法1，运算符重载
// 方法2，利用具体化的 Person 的版本实现代码，具体化优先调用
void test02() &#123;
    Person person01(10, &quot;tom&quot;);
    Person person02(10, &quot;tom&quot;);
    myCompare(person01, person02);
&#125;

int main() &#123;
    test01();
    test02();
&#125;
</code></pre>
</li>
</ul>
<ol>
<li><p>利用具体化的模板，可以解决自定义类型的通用化</p>
</li>
<li><p>学习模板不是为了写模板，而是在 STL 能够运用系统提供的模板</p>
</li>
</ol>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板的概念"><a href="#1-3-1-类模板的概念" class="headerlink" title="1.3.1 类模板的概念"></a>1.3.1 类模板的概念</h4><ol>
<li><p>作用：</p>
<ul>
<li>建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表</li>
</ul>
</li>
<li><p>语法：</p>
<pre><code>template&lt;typename T&gt;
类

// template 声明创建模板
// typename 表明其后的符号是一种数据类型，可以用class代替
// T 通用的数据类型，名称可以替换，通常为大写字母

实例：
#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

template&lt;class NameType, class AgeType&gt; // 设置类模板
class Person &#123;
public:
    AgeType m_age;
    NameType m_name;

    Person(AgeType age, NameType name) &#123;
        this-&gt;m_age = age;
        this-&gt;m_name = name;
    &#125;

    void showInfo() &#123;
        cout &lt;&lt; m_age &lt;&lt; endl;
        cout &lt;&lt; m_name &lt;&lt; endl;
    &#125;
&#125;;

void test01() &#123;
    Person&lt;string, int&gt; person01(10, &quot;tom&quot;); // 制定模板的参数的类型
    person01.showInfo();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="1-3-2-类模板和函数模板的区别："><a href="#1-3-2-类模板和函数模板的区别：" class="headerlink" title="1.3.2 类模板和函数模板的区别："></a>1.3.2 类模板和函数模板的区别：</h4><ul>
<li><p>类模板没有自动类型推导的使用方式</p>
</li>
<li><p>类模板在模板参数列表中可以有默认参数</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

template&lt;class NameType, class AgeType = int&gt; // 设置类模板,设置了类模板的默认参数 int
class Person &#123;
public:
    AgeType m_age;
    NameType m_name;

    Person(AgeType age, NameType name) &#123;
        this-&gt;m_age = age;
        this-&gt;m_name = name;
    &#125;

    void showInfo() &#123;
        cout &lt;&lt; m_age &lt;&lt; endl;
        cout &lt;&lt; m_name &lt;&lt; endl;
    &#125;
&#125;;

void test01() &#123;
    Person&lt;string, int&gt; person01(10, &quot;tom&quot;); // 制定模板的参数的类型
    person01.showInfo();
    
    // Person Person02(20, &quot;tom&quot;); // 类模板无法进行自动类型推导
    
    // 类模板在模板参数列表中可以有默认参数
    Person&lt;string&gt; person03(20, &quot;jack&quot;);
    person03.showInfo();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><ul>
<li><p>类模板中成员函数和普通类中成员函数创建时机是有区别的</p>
</li>
<li><p>类模板中的成员函数在调用时才会创建</p>
</li>
<li><p>普通类中的成员函数一开始就可以创建</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

class Person01 &#123;
public:
    // 类中的普通成员函数
    void showPerson01() &#123;
        cout &lt;&lt; &quot;showPerson01()&quot; &lt;&lt; endl;
    &#125;

&#125;;

class Person02 &#123;
public:
    // 类中的普通成员函数
    void showPerson02() &#123;
        cout &lt;&lt; &quot;showPerson02()&quot; &lt;&lt; endl;
    &#125;

&#125;;

template&lt;class T&gt;
class Person &#123;
public:
    T obj;

    // 类模板中的成员函数并不是一开始就创建，而是在模板调用时会生成
    void func01() &#123;
        obj.showPerson01();
    &#125;

    void func02() &#123;
        obj.showPerson02();
    &#125;
&#125;;

void test01() &#123;
    Person&lt;Person01&gt; person01;
    person01.func01();
    //person01.func02(); // 编译出错，说明函数调用时才会创建成员函数
    
    Person&lt;Person02&gt; person02;
    person02.func02();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ul>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><ol>
<li><p>指定传入的类型</p>
</li>
<li><p>参数模板化</p>
</li>
<li><p>整个类模板化</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

template&lt;typename NameType, class AgeType&gt;
class Person &#123;
public:
    NameType m_name;
    AgeType m_age;

    Person(NameType name, AgeType age) &#123;
        this-&gt;m_age = age;
        this-&gt;m_name = name;
    &#125;

    void showInfo() &#123;
        cout &lt;&lt; this-&gt;m_age &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_name &lt;&lt; endl;
    &#125;
&#125;;

// 1.指定传入的类型
void myPrint01(Person&lt;string, int&gt;&amp; person) &#123;
    person.showInfo();
&#125;

// 2. 将参数模板化
template&lt;typename T1, class T2&gt;
void myPrint02(Person&lt;T1, T2&gt;&amp; person) &#123;
    person.showInfo();
    cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;
&#125;

// 3. 将整个类模板化
template&lt;class T&gt;
void myPrint03(T&amp; p) &#123;
    p.showInfo();
    cout &lt;&lt; typeid(T).name() &lt;&lt; endl;
&#125;

void test01() &#123;
    Person&lt;string, int&gt; person01(&quot;jack&quot;, 10);
    myPrint01(person01); // 调用指定了传入参数的类型的函数

    Person&lt;string, int&gt; person02(&quot;tom&quot;, 20);
    myPrint02(person02);

    Person&lt;string, int&gt; person03(&quot;marry&quot;, 30);
    myPrint03(person03);
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
<li><p>最常用的是指定参入类型</p>
</li>
</ol>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><ol>
<li><p>当子类继承的父类是一个模板类时，子类在声明的时候，可以指定父类模板中的 T 类型如果不指定，编译器无法给子类分配内存</p>
</li>
<li><p>如果想灵活指定父类中的 T 类型，子类也需要设置为类模板</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 父类为类模板
template&lt;class T&gt;
class Base &#123;
    T m;
&#125;;

// 子类继承父类的类模板
/*
    class Son :public Base &#123; 
        // 这是错的，因为子类继承父类模板时，要指定父类中的 T 的类型，才能继承，
        // 若不指定子类则无法创建对象，因为并不知道子类对象需要多大的内存空间
    &#125;;
*/

class Son01 :public Base&lt;int&gt; &#123;
    // 子类继承父类模板，并指定了父类中的 T 的数据类型，这是正确的继承
&#125;;

// 如果想灵活指定父类中的 T 类型，子类也需要变为类模板
template&lt;class T1, class T2&gt;
class Son02 :public Base&lt;T2&gt; &#123; // T2 指定了父类的类模板中的 T 的类型
    T1 obj; // T1 是子类自己新建的属性，类型为T1
&#125;;

void test01() &#123;
    Son01 son01;
    Son02&lt;string, int&gt; son02;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>类模板中成员函数类外实现时，需要加上模板参数列表</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

template&lt;typename T1, typename T2&gt;
class Person &#123;
public:
    T1 m_name;
    T2 m_age;
    Person(T1 name, T2 age);

    void showInfo();
&#125;;

// 类模板成员函数类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_age = age;
    this-&gt;m_name = name;
&#125;

template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showInfo() &#123;
    cout &lt;&lt; this-&gt;m_age &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_name &lt;&lt; endl;
&#125;

void test01() &#123;
    Person&lt;string, int&gt; person01(&quot;tom&quot;, 20);
    person01.showInfo();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>产生的问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时连接不到</p>
<p>解决方式：</p>
<ul>
<li><p>直接包含 .cpp 源文件，这种方法不常用</p>
<p>.h 文件</p>
<pre><code>#pragma once

// 类声明
template&lt;typename T1, typename T2&gt;
class Person &#123;
public:
    T1 m_name;
    T2 m_age;

    Person(T1 name, T2 age);
    void showInfo();
&#125;;
</code></pre>
<p>.cpp 文件</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

// 类实现
#include&quot;Person.h&quot;
template&lt;typename T1, typename T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_age = age;
    this-&gt;m_name = name;
&#125;

template&lt;typename T1, typename T2&gt;
void Person&lt;T1, T2&gt;::showInfo() &#123;
    cout &lt;&lt; this-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;
&#125;
</code></pre>
<p>main文件</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
#include&quot;Person.cpp&quot; // 这是第一种方式：在主函数的文件中直接包含 模板类 的实现的 .cpp 文件


void test01() &#123;
    Person&lt;string, int&gt; person01(&quot;jack&quot;, 30);
    person01.showInfo();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
<li><p>将声明（.h）和实现（.cpp）写到同一个文件中，并更改后缀名为 .hpp，hpp是约定的名称，并不是强制</p>
<p>.hpp 文件</p>
<pre><code>#pragma once


// 类声明
template&lt;typename T1, typename T2&gt;
class Person &#123;
public:
    T1 m_name;
    T2 m_age;

    Person(T1 name, T2 age);
    void showInfo();
&#125;;

#include&lt;iostream&gt;
using namespace std;

// 类实现
template&lt;typename T1, typename T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_age = age;
    this-&gt;m_name = name;
&#125;

template&lt;typename T1, typename T2&gt;
void Person&lt;T1, T2&gt;::showInfo() &#123;
    cout &lt;&lt; this-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;
&#125;
</code></pre>
<p>main文件：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
#include&quot;Person.hpp&quot; 
// 这是第二种方式：将声明（.h）和实现（.cpp）写到同一个文件中，并更改后缀名为 .hpp，hpp是约定的名称，并不是强制

void test01() &#123;
    Person&lt;string, int&gt; person01(&quot;jack&quot;, 30);
    person01.showInfo();
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ul>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>掌握类模板配合友元函数的类内和类外实现</p>
<p><strong>全局函数类内实现：</strong>直接在类内声明友元即可</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

template&lt;typename T1, typename T2&gt;
class Person &#123;
private:
    T1 m_name;
    T2 m_age;

public:
    Person(T1 name, T2 age) &#123;
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    &#125;

    // 全局函数，类内实现,虽然写在了类内，但是这是全局函数
    friend void myPrint(Person&lt;T1, T2&gt;&amp; person) &#123;
        cout &lt;&lt; person.m_name &lt;&lt; &quot; &quot; &lt;&lt; person.m_age &lt;&lt; endl;
    &#125;

&#125;;

void test01() &#123;
    Person&lt;string, int&gt; person01(&quot;jack&quot;, 10);
    myPrint(person01);
&#125;
int main() &#123;
    test01();

&#125;
</code></pre>
<p><strong>全局函数类外实现：</strong>需要提前让编译器知道全局函数的存在</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

template&lt;typename T1, typename T2&gt;
class Person;

template&lt;typename T1, typename T2&gt;
void myPrint(Person&lt;T1, T2&gt;&amp; person) &#123; // 因为该函数用到了Person类，需要在该函数之前声明该类，并将该类设置为模板类
    cout &lt;&lt; person.m_name &lt;&lt; &quot; &quot; &lt;&lt; person.m_age &lt;&lt; endl;
&#125;

template&lt;typename T1, typename T2&gt;
class Person &#123;
private:
    T1 m_name;
    T2 m_age;

public:
    Person(T1 name, T2 age) &#123;
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    &#125;

    // 全局函数类外实现
    // 必须加空模板参数列表
    // 需要让编译器提前知道这个函数的存在，将该函数写在该类模板之前即可
    friend void myPrint&lt;&gt;(Person&lt;T1, T2&gt;&amp; person);

&#125;;

void test01() &#123;
    Person&lt;string, int&gt; person01(&quot;jack&quot;, 10);
    myPrint(person01);
&#125;
int main() &#123;
    test01();
&#125;
</code></pre>
<p>建议全局函数类内实现</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>实现一个通用的数组类</p>
<ol>
<li><p>可以对基本数据类型，自定义数据类型进行存放</p>
</li>
<li><p>将数组中的数据存入堆区</p>
</li>
<li><p>构造函数中可以传入数组的容量</p>
</li>
<li><p>提供对应的拷贝构造函数以及operator=防止浅拷贝的问题</p>
</li>
<li><p>提供尾插法和尾删法对数组中的数据进行增加和删除</p>
</li>
<li><p>可以通过下标的方式访问数组中的元素</p>
</li>
<li><p>可以获取数组中当前元素个数和数组的容量</p>
<pre><code>#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

template&lt;typename T&gt;
class MyArray &#123;

private:
    T* m_array;
    int m_capacity;
    int m_size;

public:
    // 构造函数
    MyArray(int capacity) &#123;
        cout &lt;&lt; &quot;构造函数调用&quot; &lt;&lt; endl;
        this-&gt;m_capacity = capacity;
        this-&gt;m_array = new T[this-&gt;m_capacity];
        this-&gt;m_size = 0;
    &#125;

    // 拷贝构造函数
    MyArray(const MyArray&amp; arr) &#123;
        cout &lt;&lt; &quot;拷贝构造函数调用&quot; &lt;&lt; endl;
        this-&gt;m_size = arr.m_size;
        this-&gt;m_capacity = arr.m_capacity;
        
        // this-&gt;m_array = arr.m_array;
        // 这会发生浅拷贝，这两个数组指向同一块堆区，当arr将指向堆区的数据释放以后，
        // 另一个在调用析构函数的时候会出错，也当然无法指向堆区的数据
        
        // 为了避免浅拷贝，可以用下面的方式，也就是深拷贝
        this-&gt;m_array = new T[arr.m_capacity];
        for (int i = 0; i &lt; arr.m_capacity; i++)
        &#123;
            this-&gt;m_array[i] = arr.m_array[i]; // 赋值运算符会进行浅拷贝，因此要重载赋值运算符
        &#125;
    &#125;
    
    // 重载 = 
    MyArray&amp; operator=(const MyArray&amp; arr) &#123;
        cout &lt;&lt; &quot;赋值运算符重载函数调用&quot; &lt;&lt; endl;
        // 重载运算符的时候首先判断 this.m_array 是否在堆区，若在堆区要先释放
        if (this-&gt;m_array != NULL)
        &#123;
            delete[] this-&gt;m_array;
            this-&gt;m_array = NULL;
        &#125;
        this-&gt;m_capacity = arr.m_capacity;
        this-&gt;m_size = arr.m_size;
        this-&gt;m_array = new T[arr.m_capacity];
        for (int i = 0; i &lt; arr.m_capacity; i++)
        &#123;
            this-&gt;m_array[i] = arr.m_array[i];
        &#125;
        return *this;
    &#125;

    // 析构函数
    ~MyArray()
    &#123;
        cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;
        if (this-&gt;m_array != NULL)
        &#123;
            delete[] this-&gt;m_array;
            this-&gt;m_array = NULL;
        &#125;
    &#125;

    // 尾插法
    void insertData(const T&amp; data) &#123; // const 防止数据在该函数中被修改，&amp; 是引用
        // 判断容量是已满
        if (this-&gt;m_size == this-&gt;m_capacity)
        &#123;
            cout &lt;&lt; &quot;该数组容量已满&quot; &lt;&lt; endl;
            return;
        &#125;
        this-&gt;m_array[this-&gt;m_size] = data;
        this-&gt;m_size++;
    &#125;

    // 尾插法
    void deleteData() &#123;
        // 判断数组是否为空
        if (this-&gt;m_size == 0)
        &#123;
            cout &lt;&lt; &quot;该数组为空，无法删除&quot; &lt;&lt; endl;
            return;
        &#125;
        // 进行数据删除
        this-&gt;m_size--;
    &#125;

    // 通过下标的方式访问数组的元素
    T&amp; operator[](int index) &#123;
        return this-&gt;m_array[index];
    &#125;

    // 返回数组的容量
    int getCapacity() &#123;
        return this-&gt;m_capacity;
    &#125;

    // 返回数组的大小
    int getSize() &#123;
        return this-&gt;m_size;
    &#125;
&#125;;
</code></pre>
<p>主程序：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
#include&quot;MyArray.hpp&quot;

class Person &#123;
public:
    string name;
    int age;

    Person()&#123;
        cout &lt;&lt; &quot;调用person的无参构造函数&quot; &lt;&lt; endl;
    &#125; // 在调用 MyArray 的构造函数中用 new 创建 Person 数组时,需要调用Person的无参构造函数

    Person(string name, int age) &#123;
        this-&gt;name = name;
        this-&gt;age = age;
    &#125;
&#125;;

void test01() &#123;
    MyArray&lt;int&gt; myArray01(5);

    for (int i = 0; i &lt; 5; i++)
    &#123;
        myArray01.insertData(i);
    &#125;

    myArray01.deleteData();
    cout &lt;&lt; myArray01.getCapacity() &lt;&lt; endl;
    cout &lt;&lt; myArray01.getSize() &lt;&lt; endl;

    MyArray&lt;int&gt; myArray02(myArray01); // 调用拷贝构造函数

    for (int i = 0; i &lt; myArray02.getSize(); i++)
    &#123;
        cout &lt;&lt; myArray02[i] &lt;&lt; endl;
    &#125;

    cout &lt;&lt; &quot;========================&quot; &lt;&lt; endl;

    MyArray&lt;int&gt; myArray03(3);
    myArray03 = myArray02; // 调用赋值运算符的重载函数

    cout &lt;&lt; &quot;========================&quot; &lt;&lt; endl;
    

&#125;

void test02() &#123;

    MyArray&lt;Person&gt; myArray(3);
    Person person01(&quot;tom&quot;, 10);
    Person person02(&quot;jack&quot;, 20);
    Person person03(&quot;marry&quot;, 30);
    myArray.insertData(person01);
    myArray.insertData(person02);

    cout &lt;&lt; myArray.getSize() &lt;&lt; endl;
    cout &lt;&lt; myArray.getCapacity() &lt;&lt; endl;

    for (int i = 0; i &lt; myArray.getSize(); i++)
    &#123;
        cout &lt;&lt; myArray[i].age &lt;&lt; &quot; &quot; &lt;&lt; myArray[i].name &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();
    cout &lt;&lt; &quot;=====================&quot; &lt;&lt; endl;
    test02();
    // 以这种方式创建数组的时候，会调用无参构造函数，因此在有有参构造函数的条件下，需要创建无参构造函数，
    Person * persons = new Person[5]; 

&#125;
</code></pre>
</li>
</ol>
<h2 id="第二章-STL"><a href="#第二章-STL" class="headerlink" title="第二章 STL"></a>第二章 STL</h2><h3 id="2-1-STL初识"><a href="#2-1-STL初识" class="headerlink" title="2.1 STL初识"></a>2.1 STL初识</h3><ol>
<li>软件界一直希望建立一种可以重复利用的东西</li>
<li>C++面向对象和泛型编程的思想目的就是复用性的提升</li>
<li>数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li>
<li>为了建立数据结构和算法的一套标准，诞生了STL</li>
</ol>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ol>
<li>STL 标准模板库（Standard Template Library）</li>
<li>STL从广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）</li>
<li>容器和算法通过迭代器进行无缝连接</li>
<li>STL几乎所有的代码都采用了模板类或者模板函数</li>
</ol>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器和算法之间的胶合剂</li>
<li>仿函数：行为类似函数、可作为算法的某种策略</li>
<li>适配器（配接器）：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4 STL中容器、算法、迭代器"></a>2.4 STL中容器、算法、迭代器</h3><ol>
<li><p><strong>容器：置物之所也</strong></p>
<ul>
<li><p>STL容器就是 <strong>将运用最广泛的一些数据结构实现</strong> 出来</p>
</li>
<li><p>常用的数据结构：数组、链表、树、栈、队列、集合、映射表等</p>
</li>
<li><p>这些容器分为序列式容器和关联式容器两种</p>
<p><strong>序列式容器：</strong>强调值的排序，序列式容器中的每个元素均有固定的位置</p>
<p><strong>关联式容器：</strong>二叉树结构，各个元素之间没有严格的物理上的顺序关系</p>
</li>
</ul>
</li>
<li><p><strong>算法：问题值解法也</strong></p>
<ul>
<li><p>有限的步骤，解决逻辑或者数学上的问题，这一门学科就是算法</p>
</li>
<li><p>算法分为：质变算法和非质变算法</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容、例如拷贝、替换、删除等</p>
<p>非质变算法：指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等</p>
</li>
</ul>
</li>
<li><p><strong>迭代器：容器和算法之间的粘合剂</strong></p>
<ul>
<li><p>算法要通过迭代器才能访问容器中的数</p>
</li>
<li><p>每个容器都有自己专属的迭代器</p>
</li>
<li><p>迭代器的使用非常类似于指针</p>
</li>
<li><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</p>
</li>
<li><p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以跳跃的访问任意数据，功能最强</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>常用的容器为：双向迭代器  和  随机访问迭代器</p>
<p>iterator 为可读可写迭代器</p>
<p>const_iterator 为只可读的迭代器</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><ol>
<li>STL中常用的容器为vector，可以理解为数组</li>
</ol>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：vector</p>
<p>算法：for_each</p>
<p>迭代器：vector<int>::iterator</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt; // 要包含头文件
#include&lt;algorithm&gt; // 包含了 for_each

void myPrint(int value);

void test01() &#123;
    // vector 存储基本数据类型
    vector&lt;int&gt; v;

    // 添加数据
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);

    vector&lt;int&gt;::iterator itBegin = v.begin(); // 起始迭代器，指向容器中的第一个元素,返回的是元素的指针
    vector&lt;int&gt;::iterator itEnd = v.end(); // 结束迭代器，指向容器中最后一个元素的下一个位置，返回的是一个指针
    
    // 第一种遍历方式
    while (itBegin != itEnd)
    &#123;
        cout &lt;&lt; *itBegin &lt;&lt; endl;
        itBegin++; // 要将 itBegin 指向下一个元素
    &#125;

    // 第二种遍历方式
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; endl;
    &#125;

    // 第三种遍历方式
    for_each(v.begin(), v.end(), myPrint); // myPrint利用了回调的技术
&#125;

void myPrint(int value) &#123;
    cout &lt;&lt; value &lt;&lt; endl;
&#125;


int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="2-5-2-vector存放自定义数据类型"><a href="#2-5-2-vector存放自定义数据类型" class="headerlink" title="2.5.2 vector存放自定义数据类型"></a>2.5.2 vector存放自定义数据类型</h4><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

class Person &#123;
public:
    int m_age;
    string m_name;

    Person(int age, string name) &#123;
        this-&gt;m_age = age;
        this-&gt;m_name = name;
    &#125;
&#125;;

// 在vector中存放Person类型对象
void test01() &#123;
    vector&lt;Person&gt; vectorPerson;

    Person perosn01(10, &quot;tom&quot;);
    Person person02(20, &quot;jack&quot;);
    Person person03(30, &quot;jerry&quot;);

    vectorPerson.push_back(perosn01);
    vectorPerson.push_back(person02);
    vectorPerson.push_back(person03);

    for (vector&lt;Person&gt;::iterator it = vectorPerson.begin(); it != vectorPerson.end(); it++)
    &#123;
        cout &lt;&lt; (*it).m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it).m_age &lt;&lt; endl;
        cout &lt;&lt; it-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;m_age &lt;&lt; endl;
    &#125;
&#125;

// 在vector中存放Person类型的对象的指针
void test02() &#123;
    vector&lt;Person*&gt; vectorPerson;

    Person perosn01(10, &quot;tom&quot;);
    Person person02(20, &quot;jack&quot;);
    Person person03(30, &quot;jerry&quot;);

    vectorPerson.push_back(&amp;perosn01);
    vectorPerson.push_back(&amp;person02);
    vectorPerson.push_back(&amp;person03);

    for (vector&lt;Person*&gt;::iterator it = vectorPerson.begin(); it != vectorPerson.end(); it++)
    &#123;
        cout &lt;&lt; (*it)-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it)-&gt;m_age &lt;&lt; endl;
    &#125;
&#125;


int main() &#123;
    test01();
    cout &lt;&lt; &quot;==============================&quot; &lt;&lt; endl;
    test02();
&#125;
</code></pre>
<h4 id="2-5-3-vector容器再嵌套一个容器"><a href="#2-5-3-vector容器再嵌套一个容器" class="headerlink" title="2.5.3 vector容器再嵌套一个容器"></a>2.5.3 vector容器再嵌套一个容器</h4><p>容器嵌套容器，将数据全部输出，这类似于一个二维数组</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

// 容器嵌套
void test01() &#123;
    // 设置外层容器
    vector&lt; vector&lt;int&gt; &gt; bigVector;

    // 设置内层容器
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;
    vector&lt;int&gt; v4;

    // 向内层容器中添加数据
    for (int i = 0; i &lt; 4; i++)
    &#123;
        v1.push_back(i + 1);
        v2.push_back(i + 2);
        v3.push_back(i + 3);
        v4.push_back(i + 4);
    &#125;

    // 将内层容器加入到外层容器中
    bigVector.push_back(v1);
    bigVector.push_back(v2);
    bigVector.push_back(v3);
    bigVector.push_back(v4);

    // 遍历输出所有数据
    for (vector&lt; vector&lt;int&gt; &gt;::iterator bigV = bigVector.begin(); bigV != bigVector.end(); bigV++)
    &#123;    
        // (*bigV) -&gt; 内层的容器 vector&lt;int&gt;
        for (vector&lt;int&gt;::iterator it = (*bigV).begin(); it != (*bigV).end(); it++)
        &#123;
            cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h2 id="第三章-STL-常用容器"><a href="#第三章-STL-常用容器" class="headerlink" title="第三章 STL 常用容器"></a>第三章 STL 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string容器基本概念"><a href="#3-1-1-string容器基本概念" class="headerlink" title="3.1.1 string容器基本概念"></a>3.1.1 string容器基本概念</h4><ol>
<li><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质是一个类</li>
</ul>
</li>
<li><p><em><em>string和char</em> 区别：</em>*</p>
<ul>
<li>char* 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个 char *  型的容器</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>string类内部封装了很多成员方法</li>
<li>例如：查找find、拷贝copy、删除delete、替换replace、插入insert</li>
<li>string管理char * 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</li>
</ul>
</li>
</ol>
<h4 id="3-1-2-string容器构造函数"><a href="#3-1-2-string容器构造函数" class="headerlink" title="3.1.2 string容器构造函数"></a>3.1.2 string容器构造函数</h4><pre><code>string(); // 创建一个空的字符串，例如：string str;
string(const char* s); // 使用字符串s初始化
string(const string&amp; str); // 使用一个string对象初始化另一个string对象
string(int n, char c); // 使用 n 个字符c初始化
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void test01() &#123;
    string s1;
    cout &lt;&lt; s1 &lt;&lt; endl;

    const char* str02 = &quot;helloworld02&quot;;
    string s2(str02);
    cout &lt;&lt; s2 &lt;&lt; endl;

    const string&amp; str03 = &quot;helloworld03&quot;;
    string s3(str03);
    cout &lt;&lt; s3 &lt;&lt; endl;

    string s4(5, &#39;a&#39;);
    cout &lt;&lt; s4 &lt;&lt; endl;

    string s5 = &quot;helloworld05&quot;; // c++ 风格的字符串
    cout &lt;&lt; s5 &lt;&lt; endl;

    char ch[] = &quot;helloworld06&quot;; // c语言风格的字符串
    cout &lt;&lt; ch &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="3-1-3-string容器赋值操作"><a href="#3-1-3-string容器赋值操作" class="headerlink" title="3.1.3 string容器赋值操作"></a>3.1.3 string容器赋值操作</h4><p>给string字符串进行赋值</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;

void test01() &#123;
    // string&amp; operator=(const char* s); char* s 类型的字符串赋值给当前的字符串s1
    string s1 = &quot;helloworld01&quot;; 
    cout &lt;&lt; s1 &lt;&lt; endl;

    // string&amp; operator=(const string&amp; s); 把字符串s赋值给当前字符串
    const string&amp; s = &quot;helloworld02&quot;;
    string s2 = s;
    cout &lt;&lt; s2 &lt;&lt; endl;

    // string&amp; operator=(char c); 把字符赋值给当前的字符串
    string s3;
    s3 = &#39;a&#39;;
    cout &lt;&lt; s3 &lt;&lt; endl;

    // string&amp; assign(const char* s); 把字符串s赋值给当前的字符串
    string s4;
    s4.assign(&quot;helloworld04&quot;);
    cout &lt;&lt; s4 &lt;&lt; endl;

    // string&amp; assign(const string&amp; s); 把字符串s赋值给当前字符串
    string s5;
    s5.assign(&quot;helloworld05&quot;);
    cout &lt;&lt; s5 &lt;&lt; endl;

    // string&amp; assign(int n, char c); n个c
    string s6;
    s6.assign(5, &#39;a&#39;);
    cout &lt;&lt; s6 &lt;&lt; endl;
    
    // string&amp; assign(const char* s, int n); 截取字符串的前 n 个字符
    string s7;
    s7.assign(&quot;helloworld07&quot;, 6);
    cout &lt;&lt; s7 &lt;&lt; endl; // hellow
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="3-1-4-string容器字符串拼接"><a href="#3-1-4-string容器字符串拼接" class="headerlink" title="3.1.4 string容器字符串拼接"></a>3.1.4 string容器字符串拼接</h4><p>在字符串末尾拼接字符串</p>
<pre><code>string&amp; operator+=(const char* s); // 重载+=字符串
string&amp; operator+=(const char c); // 重载+=字符串
string&amp; operator+=(const string&amp; s); // 重载+=字符串
string&amp; append(const char* s); // 把字符串拼接到字符串末尾
string&amp; append(const char* s, int n); // 把字符串的前 n 个字符拼接到字符串末尾
string&amp; append(const string&amp; s); // 将字符串拼接到字符串末尾
string&amp; append(const string&amp; s, int pos, int n); // 截取字符串，从pos开始截取n个字符
</code></pre>
<h4 id="3-1-5-string容器查找和替换"><a href="#3-1-5-string容器查找和替换" class="headerlink" title="3.1.5 string容器查找和替换"></a>3.1.5 string容器查找和替换</h4><p>查找：查找指定字符串是否存在</p>
<p>替换：在指定的位置替换字符串</p>
<pre><code>int find(const string&amp; str, int pos = 0); // 查找str第一次出现的位置，从pos位置开始查找，返回查找到的字符串的下标位置，若没有找到则返回-1
int rfind(const string&amp; str, int pos = npos); // 返回的是查找到的字符串的下标,查找str最后一次出现的位置，从pos开始查找
// rfind 和 find 区别：
// rfind 是从右往左查找，find是从左往右查找
</code></pre>
<pre><code>string&amp; repalce(int pos, int n, const string&amp; str); // 替换从pos开始的n个字符为str
</code></pre>
<h4 id="3-1-6-string容器字符串比较"><a href="#3-1-6-string容器字符串比较" class="headerlink" title="3.1.6 string容器字符串比较"></a>3.1.6 string容器字符串比较</h4><p>字符串比较是按照字符的ASCII码进行对比</p>
<p>=  返回 0</p>
<p>“ &gt; “ 返回 1</p>
<p>“&lt; “ 返回 -1</p>
<pre><code>str1.compare(str2); // 字符串中的字符一个一个的对比
</code></pre>
<h4 id="3-1-7-string容器字符存取"><a href="#3-1-7-string容器字符存取" class="headerlink" title="3.1.7 string容器字符存取"></a>3.1.7 string容器字符存取</h4><pre><code>string中单个字符存取方式有两种
str.size(); 可以返回字符串的长度

char&amp; operator[](int n); // 通过[]方式存取字符

char&amp; at(int n);//通过at方法存取数据
</code></pre>
<h4 id="3-1-8-string容器插入和删除"><a href="#3-1-8-string容器插入和删除" class="headerlink" title="3.1.8 string容器插入和删除"></a>3.1.8 string容器插入和删除</h4><p>对字符串进行插入和删除</p>
<pre><code>string&amp; insert(int pos, const char* s); // 从pos开始，插入字符串
string&amp; erase(int pos, int n = npos); // 从pos起，删除n个字符
</code></pre>
<h4 id="3-1-9-string容器子串获取"><a href="#3-1-9-string容器子串获取" class="headerlink" title="3.1.9 string容器子串获取"></a>3.1.9 string容器子串获取</h4><pre><code>string substr(int pos = 0, int n = npos); // 从字符串的pos起，截取n个字符返回字串
</code></pre>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><ol>
<li><p>vector 数据结构和数组非常相似，也称为单端数组</p>
</li>
<li><p>普通数组是静态空间，不可以扩展，而vector可以动态扩展</p>
</li>
<li><p>动态扩展：并不是再原空间之后接新空间，而是找更大的内存空间，然后将源数据拷贝到新空间，释放原空间</p>
</li>
<li><p>vector容器的迭代器是支持随机访的迭代器</p>
</li>
<li><p>在使用容器时要包含头文件</p>
</li>
<li><p>push_back()； 尾加数据</p>
</li>
<li><p>vector是一组连续的内存空间</p>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220426102326366.png" alt="image-20220426102326366"></p>
</li>
</ol>
<h4 id="3-2-2-构造函数"><a href="#3-2-2-构造函数" class="headerlink" title="3.2.2 构造函数"></a>3.2.2 构造函数</h4><ol>
<li><p>创建vector容器</p>
</li>
<li><p>函数原型：</p>
<pre><code>vector&lt;T&gt; v; // 采用模板实现类实现，默认构造函数
vector&lt;T&gt; v(v.begin(), v.end()); // 通过区间方式进行构造
vector&lt;T&gt; v(int n, T elem) // 将n个elem拷贝给自身
vector&lt;T&gt; v(const vector&amp; vec); // 拷贝构造
</code></pre>
</li>
</ol>
<h4 id="3-2-3-vector-赋值操作"><a href="#3-2-3-vector-赋值操作" class="headerlink" title="3.2.3 vector 赋值操作"></a>3.2.3 vector 赋值操作</h4><p>给vector容器进行赋值</p>
<pre><code>vector&amp; operator=(const vector&amp; vec); // 重载等号操作符
assign(v.begin(), v.end()); // 将v的区间赋值给容器
assign(n, elem); // n个elem赋值给容器
</code></pre>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4 vector容量和大小"></a>3.2.4 vector容量和大小</h4><p>对vector容量和大小操作</p>
<pre><code>empty(); // 判断容器是否为空
capacity(); // 容器的容量,有动态扩展机制
size(); // 返回容器中元素的个数,容器的容量和元素个数不是一回事
resize(int n); // 重新制定大小，也就是重新设置了capacity,过长的位置用默认值填充
resize(int n, T elem); // 重新设置容器的大小为n，多余的部分用elem填充，如果重新指定的大小变小了，就会将多出的数据删除
</code></pre>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p>对vector容器进行插入、删除操作</p>
<pre><code>push_pack(T elem); // 在容器尾部插入elem
pop_back(); // 删除最后一个元素
insert(const_iterator pos, elem); //迭代器指向位置pos插入元素ele
insert(const_iterator pos, int count, T elem); // 迭代器指向位置pos插入count个元素elem
erase(const_iterator pos); // 删除迭代器指向的元素
erase(const_iterator start, const_iterator end); // 删除迭代器从start到end之间的元素
clear(); // 删除容器总的所有元素
</code></pre>
<h4 id="3-2-6-数据存取"><a href="#3-2-6-数据存取" class="headerlink" title="3.2.6 数据存取"></a>3.2.6 数据存取</h4><p>对vector容器中的数据的存取操作</p>
<pre><code>at(int index); // 返回索引index指向的数据
operator[]; // 返回索引index指向的数据
front(); // 返回容器中第一个数据元素
back(); // 返回容器中最后一个数据元素 
</code></pre>
<h4 id="3-2-7-互换容器"><a href="#3-2-7-互换容器" class="headerlink" title="3.2.7 互换容器"></a>3.2.7 互换容器</h4><p>实现两个容器元素的交换</p>
<pre><code>swap(vector); // 将vector互换元素
</code></pre>
<p>实际用途：</p>
<p>swap可以收缩内存空间</p>
<pre><code>vector&lt;int&gt; v;
v.push_back(i); // i从1到1000;循环加入v

v.resize(3); // 重新指定了大小，但是此容器的capacity()不改变，这就会使得空间浪费
// 巧用swap()收缩内存
vector&lt;int&gt;(v).swap(v); // vector&lt;int&gt;(v); 是匿名对象， .swap(v);相当于做了容器的交换
// 匿名对象会被系统回收
</code></pre>
<h4 id="3-2-8-预留空间"><a href="#3-2-8-预留空间" class="headerlink" title="3.2.8 预留空间"></a>3.2.8 预留空间</h4><p>减少vector在动态扩展容量时的扩展次数</p>
<pre><code>reserve(int len); // 容器预留len个元素长度，预留位置不初始化，元素不可访问
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

void test01() &#123;
    vector&lt;int&gt; v1;
    
    // 利用reserve预留空间
    v1.reserve(100000); // 预留了100000个空间，则只需要扩容一次，num = 1；

    int num = 0; // 统计开辟的次数
    int* p = NULL;
    for (int i = 0; i &lt; 100000; i++)
    &#123;
        v1.push_back(i);
        if (p != &amp;v1[0]) // 每次扩容以后，容器的首地址都会改变，因此num++
        &#123;
            p = &amp;v1[0];
            num++;
        &#125;
    &#125;
    cout &lt;&lt; num &lt;&lt; endl;
    cout &lt;&lt; v1.capacity() &lt;&lt; endl;

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器的基本概念"><a href="#3-3-1-deque容器的基本概念" class="headerlink" title="3.3.1 deque容器的基本概念"></a>3.3.1 deque容器的基本概念</h4><ol>
<li><p>双端数组，可以对头端进行插入删除操作</p>
</li>
<li><p>要包含头文件</p>
</li>
<li><p>deque和vector区别：</p>
<ul>
<li><p>vector 对于头部的插入和删除效率低，数据量越大，效率越低，因为插入删除要移动大量数据</p>
</li>
<li><p>deque相对而言，对头部的删除插入速度比vector快</p>
</li>
<li><p>vector访问元素速度会比deque快，这和两者的内部实现相关</p>
</li>
<li><p>deque容器的迭代器也是支持随机访问的</p>
</li>
</ul>
</li>
</ol>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220426101809778.png" alt="image-20220426101809778"></p>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220426102108888.png" alt="image-20220426102108888"></p>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><pre><code>deque&lt;T&gt; deqT; // 默认构造
deque(begin, end); // 构造函数将[begin,end)区间中的元素拷贝到deque容器
deque(n, elem); // 构造函数将n个elem拷贝到deque容器
deque(const deque&amp; deque); // 拷贝构造函数
</code></pre>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p>给deque容器进行赋值</p>
<pre><code>deque&amp; operator=(const deque &amp;deq); // 重载 = 运算符
assign(begin(), end()); // 将[begin, end) 区间中的数据拷贝赋值给容器
assign(n, elem); // 将n个elem拷贝赋值给容器
</code></pre>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p>对deque的容器大小进行操作</p>
<p>没有容量的大小，因为该容器可以无线扩展，中控器是不变的</p>
<pre><code>deque.empty(); // 判断容器是否为空
deque.size(); // 返回容器中的元素个数
deque.resize(int num); // 重新指定容器的长度为 num，若容器过长，则以默认值填充新位置，如果容器过短，则末尾超出容器的长度的元素被删除
deque.resize(int num, T elem); // 重新指定容器的长度为num， 若容器过长，则以elem值填充，如果容器变短，则末尾超出容器长度的元素被删除
</code></pre>
<h4 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h4><p>两端插入删除操作：</p>
<pre><code>push_back(elem); // 在容器尾部添加一个数据
push_front(elem); // 在容器头部插入一个数据
pop_back(); // 删除容器最后一个数据
pop_front(); // 删除容器第一个数据
</code></pre>
<p>指定位置操作：</p>
<pre><code>insert(pos, elem); // 在pos位置插入一个elem元素的拷贝，返回新数据的位置
insert(pos, n, elem); // 在pos位置插入n个elem数据，无返回值
insert(pos, begin, end); // 在pos位置插入[begin, end)区间的数据，无返回值
clear(); // 清空容器中的数据
erase(begin, end); // 删除[begin, end)区间的数据，返回下一个数据的位置
erase(pos); // 删除pos位置的数据，返回下一个数据的位置
</code></pre>
<p>位置都是迭代器</p>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><pre><code>at(int index); // 返回索引index所指的数据
operator[]; // 返回索引所指的数据元素
front(); // 返回容器中的第一个元素
back(); // 返回容器中的最后一个元素
</code></pre>
<h4 id="3-3-7-排序"><a href="#3-3-7-排序" class="headerlink" title="3.3.7 排序"></a>3.3.7 排序</h4><p>对容器中的数据进行排序</p>
<p>所有标准算法都要包含头文件：#include<algorithm></p>
<p>对于支持随机访问的迭代器的容器，都可以利用sort算法直接对其进行排序</p>
<p>vector 和 deque 都可以利用 sort 进行排序</p>
<pre><code>sort(iterator begin, iterator end); // 对begin 和 end 区间内元素进行排序 
</code></pre>
<h3 id="3-4-stack-容器"><a href="#3-4-stack-容器" class="headerlink" title="3.4 stack 容器"></a>3.4 stack 容器</h3><h4 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1 基本概念"></a>3.4.1 基本概念</h4><ol>
<li><p>概念：stack是一种先进先出的数据结构，它只有一共出口</p>
</li>
<li><p>栈中只有栈顶元素才可以被外界访问，因此栈不可以有遍历行为</p>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220427091716514.png" alt="image-20220427091716514"></p>
</li>
<li><p>栈可以判断是否为空，empty()</p>
</li>
<li><p>栈可以返回元素个数，size()</p>
</li>
<li><p>生活中的栈：压弹夹等</p>
</li>
</ol>
<h4 id="3-4-2-常用接口"><a href="#3-4-2-常用接口" class="headerlink" title="3.4.2 常用接口"></a>3.4.2 常用接口</h4><pre><code>// 构造函数
stack&lt;T&gt; stk; // stack采用模板类实现，stack对象的默认构造形式
stack(cosnt stack&amp; stk); // 拷贝构造函数

// 赋值操作
stack&amp; operator=(const stack &amp;stk); // 重载等号运算符

// 数据存取
push(elem); // 向栈顶添加元素
pop(); // 从栈顶移除一个元素
top(); // 返回栈顶元素

// 大小操作
empty(); // 判断堆栈是否为空
size(); // 返回栈的大小
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;

void test01() &#123;
    stack&lt;int&gt; stk;

    if (stk.empty())
    &#123;
        stk.push(1);
        stk.push(2);
    &#125;
    else
    &#123;
        stk.pop();
    &#125;

    cout &lt;&lt; stk.top() &lt;&lt; endl;

    cout &lt;&lt; stk.size() &lt;&lt; endl;

    stack&lt;int&gt; stk1;
    stk1 = stk;
    cout &lt;&lt; stk1.top() &lt;&lt; endl;
    cout &lt;&lt; stk1.size() &lt;&lt; endl;

    stack&lt;int&gt; stk2;
    stk2 = stk1;
    cout &lt;&lt; stk2.size() &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h3 id="3-5-queue容器"><a href="#3-5-queue容器" class="headerlink" title="3.5 queue容器"></a>3.5 queue容器</h3><h4 id="3-5-1-queue基本概念"><a href="#3-5-1-queue基本概念" class="headerlink" title="3.5.1 queue基本概念"></a>3.5.1 queue基本概念</h4><ol>
<li>queue是一种先进先出的数据结构</li>
<li>队列中允许一端进数据，另一端出数据</li>
<li>队列中只有对头和队尾能被外界访问，因此不允许有遍历行为</li>
<li>出队 pop();</li>
<li>入队push();</li>
<li>是否为空empty();</li>
<li><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220427094321125.png" alt="image-20220427094321125"></li>
</ol>
<h4 id="3-5-2-常用接口"><a href="#3-5-2-常用接口" class="headerlink" title="3.5.2 常用接口"></a>3.5.2 常用接口</h4><pre><code>// 构造函数
queue&lt;T&gt; que; // queue采用模板类实现，queue对象的默认构造函数
queue(const queue&amp; que); // 拷贝构造函数

// 赋值操作
queue&amp; operator=(const queue&amp; que); // 重载等号操作符

// 数据存取
push(elem); // 往队尾添加元素
pop(); // 从队头移除第一个元素
back(); // 返回最后一个元素
front(); // 返回第一个元素

// 大小操作
empty(); // 判断队列是否为空
size(); // 返回队列的大小
</code></pre>
<h3 id="3-6-list容器"><a href="#3-6-list容器" class="headerlink" title="3.6 list容器"></a>3.6 list容器</h3><h4 id="3-6-1-list基本概念"><a href="#3-6-1-list基本概念" class="headerlink" title="3.6.1 list基本概念"></a>3.6.1 list基本概念</h4><ol>
<li><p>将数据进行链式存储</p>
</li>
<li><p>链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
</li>
<li><p>链表的组成：链表由一系列结点组成</p>
</li>
<li><p>结点的组成：一个存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
</li>
<li><p>STL中的链表是一个<strong>双向循环链表</strong></p>
</li>
<li><p>可以对任意位置进行快速插入或删除元素，不像数组那样还需要移动大量元素</p>
</li>
<li><p>缺点：容器遍历元素的速度没有数组快、占用的内存空间要比数组大，list容器时间和空间消耗比较大</p>
</li>
<li><p>List有一个重要的性质：插入和删除操作都不会造成原有list迭代器的失效，这在vector中是不成立的</p>
</li>
<li><p>List和vector是最常被使用的容器，各有优缺点</p>
<p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220427102533878.png" alt="image-20220427102533878"></p>
</li>
</ol>
<h4 id="3-6-2-构造函数"><a href="#3-6-2-构造函数" class="headerlink" title="3.6.2 构造函数"></a>3.6.2 构造函数</h4><pre><code>list&lt;T&gt; lst; // list采用模板类实现，对象的默认构造方式
list(begin, end); // 利用list的区间构造另一个list
list(const list&amp; lst); // 拷贝构造
list(int n, elem); // n个elem构造list
</code></pre>
<h4 id="3-6-3-list-赋值和交换"><a href="#3-6-3-list-赋值和交换" class="headerlink" title="3.6.3 list 赋值和交换"></a>3.6.3 list 赋值和交换</h4><pre><code>assign(begin, end); // 将区间赋值给list
assign(int n, elem); // n个elem赋值给list
operator=(); // list02 = list01; 列表赋值
list02.swap(list01); // 交换两个容器中的元素 
</code></pre>
<h4 id="3-6-4-大小操作"><a href="#3-6-4-大小操作" class="headerlink" title="3.6.4 大小操作"></a>3.6.4 大小操作</h4><pre><code>size(); // 返回list中的元素个数
empty(); // 判断容器是否为空
resize(int n,  elem); // 重新指定list中元素的个数，并用elem填充多余的空间
resize(int n) // 重新指定list中的元素个数
</code></pre>
<h4 id="3-6-5-list-插入和删除"><a href="#3-6-5-list-插入和删除" class="headerlink" title="3.6.5 list 插入和删除"></a>3.6.5 list 插入和删除</h4><p><img src="C:\Users\haozh\AppData\Roaming\Typora\typora-user-images\image-20220427105040831.png" alt="image-20220427105040831"></p>
<h4 id="3-6-6-list数据存取"><a href="#3-6-6-list数据存取" class="headerlink" title="3.6.6 list数据存取"></a>3.6.6 list数据存取</h4><p>链表不能用中括号[]、at();方式跳跃式的访问数据，也就是不支持随机访问</p>
<p>只能用迭代器顺序去访问数据</p>
<p>只能自增自减、不能用迭代器 + 2；的类似操作</p>
<pre><code>front(); // 返回list中的第一个元素
back(); // 返回list中的最后一个元素
</code></pre>
<h4 id="3-6-7-list反转和排序"><a href="#3-6-7-list反转和排序" class="headerlink" title="3.6.7 list反转和排序"></a>3.6.7 list反转和排序</h4><pre><code>reverse(); // 反转链表
sort(); // 链表排序 
// list就是不支持随机访问迭代器的容器，其内部会提供sort()算法，可以直接调用，list.sort();这是默认的升序
// 默认的排序规则是从小到大
// 所有不支持随机访问的迭代器的容器，不可以用标准算法
</code></pre>
<h4 id="3-6-8-排序案列"><a href="#3-6-8-排序案列" class="headerlink" title="3.6.8 排序案列"></a>3.6.8 排序案列</h4><p>描述：将Person自定义数据类型进行排序，Person中有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
#include&lt;list&gt;

class Person &#123;
public:
    string m_name;
    int m_age;
    int m_high;

    Person(string name, int age, int high) &#123;
        this-&gt;m_age = age;
        this-&gt;m_high = high;
        this-&gt;m_name = name;
    &#125;
&#125;;

// 仿函数，指定排序规则
bool comparePerson(Person&amp; person01, Person&amp; person02) &#123;
    if (person01.m_age &lt; person02.m_age)
    &#123;
        return true;
    &#125;
    else if (person01.m_age == person02.m_age)
    &#123;
        return person01.m_high &gt; person02.m_high;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;

void test01() &#123;
    // 创建5个Person对象
    Person person01(&quot;tom&quot;, 10, 167);
    Person person02(&quot;jack&quot;, 20, 155);
    Person person03(&quot;smith&quot;, 10, 169);
    Person person04(&quot;jerry&quot;, 20, 177);
    Person person05(&quot;marry&quot;, 30, 180);
    
    // 将 5个人放入list
    list&lt;Person&gt; personList;
    personList.push_back(person01);
    personList.push_back(person02);
    personList.push_back(person03);
    personList.push_back(person04);
    personList.push_back(person05);

    // 排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序
    // 写一个仿函数设置排序规则
    personList.sort(comparePerson);

    // 输出列表
    for (list&lt;Person&gt;::iterator it = personList.begin(); it != personList.end(); it++)
    &#123;
        cout &lt;&lt; (*it).m_name &lt;&lt; &quot;\t&quot; &lt;&lt; (*it).m_age &lt;&lt; &quot;\t&quot; &lt;&lt; (*it).m_high &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h3 id="3-7-set-multiset容器"><a href="#3-7-set-multiset容器" class="headerlink" title="3.7 set/multiset容器"></a>3.7 set/multiset容器</h3><h4 id="3-7-1-set基本概念"><a href="#3-7-1-set基本概念" class="headerlink" title="3.7.1 set基本概念"></a>3.7.1 set基本概念</h4><ol>
<li>所有元素都会在插入时自动被排序</li>
<li>set/multiset属于关联式容器，底层结构是用二叉树实现的</li>
<li>set和multiset区别：<ul>
<li>set不允许有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
</li>
</ol>
<h4 id="3-7-2-set构造和赋值"><a href="#3-7-2-set构造和赋值" class="headerlink" title="3.7.2 set构造和赋值"></a>3.7.2 set构造和赋值</h4><pre><code>set&lt;T&gt; set01; // 默认构造
set(const set&amp; set01); // 拷贝构造
operator=(); // 重载 = ，拷贝构造

set01.insert(T elem); // 插入数据
</code></pre>
<h4 id="3-7-3-set大小和交换"><a href="#3-7-3-set大小和交换" class="headerlink" title="3.7.3 set大小和交换"></a>3.7.3 set大小和交换</h4><pre><code>size(); // 返回容器中的元素数目，不支持重新指定容器的大小
empty(); // 判断容器是否为空
set02.swap(set01); // 交换容器中的元素 
</code></pre>
<h4 id="3-7-4-set插入和删除"><a href="#3-7-4-set插入和删除" class="headerlink" title="3.7.4 set插入和删除"></a>3.7.4 set插入和删除</h4><pre><code>insert(elem); // 在容器中插入元素，
clear(); // 清除容器中的元素
erase(pos); // 删除pos迭代器所指的元素，
erase(elem); // 删除elem元素
erase(set01.begin(), set01.end()); // 删除区间中的元素
</code></pre>
<h4 id="3-7-5-set查找和统计"><a href="#3-7-5-set查找和统计" class="headerlink" title="3.7.5 set查找和统计"></a>3.7.5 set查找和统计</h4><p>对set容器进行查找数据以及统计数据</p>
<pre><code>find(key); // 查找是否找到key， 若存在，则返回该key的迭代器，不存在，则返回end()迭代器
count(key); // 对于set而言，统计结果要么是0，要么是1
</code></pre>
<h4 id="3-7-6-set和multiset区别"><a href="#3-7-6-set和multiset区别" class="headerlink" title="3.7.6 set和multiset区别"></a>3.7.6 set和multiset区别</h4><ol>
<li>set插入数据的时候会返回插入结果，表示是否成功</li>
<li>multiset不会检测数据，因此可以插入重复的数据</li>
</ol>
<h4 id="3-7-7-pair对组创建"><a href="#3-7-7-pair对组创建" class="headerlink" title="3.7.7 pair对组创建"></a>3.7.7 pair对组创建</h4><p>成对出现的数据，利用对组可以返回两个数据</p>
<pre><code>pair&lt;type, type&gt; p(value1, value2);
pair&lt;type, type&gt; p = make_pair(value1, value2);
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void test01() &#123;
    pair&lt;string, int&gt; p1(&quot;tom&quot;, 12);
    cout &lt;&lt; p1.first &lt;&lt; &quot; &quot; &lt;&lt; p1.second &lt;&lt; endl;

    pair&lt;string, int&gt; p2 = make_pair(&quot;jerry&quot;, 20);
    cout &lt;&lt; p2.first &lt;&lt; &quot; &quot; &lt;&lt; p2.second &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="3-7-8-set容器排序"><a href="#3-7-8-set容器排序" class="headerlink" title="3.7.8 set容器排序"></a>3.7.8 set容器排序</h4><p>set容器默认是从小到大排序，但是可以利用仿函数可以改变排序规则</p>
<p>对基本数据类型需改排序规则案例：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;set&gt;

class MyCompare &#123;
public:
    // 要在函数参数列表后面加const，我也不知道为什么，不加就会报错 
    //错误：C3848，具有类型“const MyCompare”的表达式会丢失一些 const - volatile 限定符以调用“bool MyCompare::operator ()(int, int)”

    bool operator()(int v1, int v2)const &#123; // 第一个括号是（）重载，第二个括号是参数列表
        return v1 &gt; v2;
    &#125;
&#125;;

// 存放基本数据类型
void test01() &#123;
    set&lt;int&gt; s1;
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(60);
    s1.insert(50);
    
    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    set&lt;int, MyCompare&gt; s2; // 在插入数据之前，指定仿函数，可以修改排序规则
    s2.insert(10);
    s2.insert(30);
    s2.insert(20);
    s2.insert(60);
    s2.insert(50);

    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<p>对自定义数据类型修改排序规则案例：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;

class Person &#123;
public:
    string m_name;
    int m_age;

    Person(int age, string name) &#123;
        this-&gt;m_age = age;
        this-&gt;m_name = name;
    &#125;
&#125;;

class MyCompare &#123;
public:
    bool operator()(const Person&amp; p1, const Person&amp; p2) const &#123;
        // 用const修饰，可以放置数据被修改，用引用可以使形参和实参指向内存中的同一块空间
        // 若形参不加引用，就会调用默认的拷贝构造函数来给形参赋值，这就可能引发浅拷贝的问题
        // 按照年龄从小到大排序set中的person元素
        return p1.m_age &lt; p2.m_age;
    &#125;
&#125;;

void test01() &#123;
    // 因此这是自定义数据类型，因此编译器不知道该按照什么方式自动排序，因此需要在插入数据之前，用仿函数指定排序规则
    set&lt;Person, MyCompare&gt; personSet;

    Person person01(10, &quot;tom&quot;);
    Person person02(50, &quot;marry&quot;);
    Person person03(30, &quot;smith&quot;);
    Person person04(20, &quot;jerry&quot;);

    personSet.insert(person01);
    personSet.insert(person02);
    personSet.insert(person03);
    personSet.insert(person04);

    for (set&lt;Person&gt;::iterator it = personSet.begin(); it != personSet.end(); it++)
    &#123;
        cout &lt;&lt; (*it).m_name &lt;&lt; &quot;\t&quot; &lt;&lt; (*it).m_age &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32739503/article/details/83341222">(12条消息) c++　在函数后加const的意义：_qq_32739503的博客-CSDN博客_函数后加const</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whahu1989/article/details/80501685">(12条消息) C++成员函数形参列表后的const_爱就是恒久忍耐的博客-CSDN博客_参数列表后的const</a></p>
<h3 id="3-8-map-multimap容器"><a href="#3-8-map-multimap容器" class="headerlink" title="3.8 map/multimap容器"></a>3.8 map/multimap容器</h3><h4 id="3-8-1-map基本概念"><a href="#3-8-1-map基本概念" class="headerlink" title="3.8.1 map基本概念"></a>3.8.1 map基本概念</h4><ol>
<li>map中所有元素都是pair</li>
<li>pair中的第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
<li>map/multimap属于关联式容器，底层结构是用二叉树实现的</li>
<li>可以根据key值快速找到value值</li>
<li>map中不允许容器中有重复的key值</li>
<li>multimap中允许有重复的key值</li>
</ol>
<h4 id="3-8-2-构造和赋值"><a href="#3-8-2-构造和赋值" class="headerlink" title="3.8.2 构造和赋值"></a>3.8.2 构造和赋值</h4><pre><code>map&lt;type, type&gt; m1; // 第一个为key的类型，第二个为value的类型
map(const map&amp; mp); // 拷贝构造函数
map&amp; operator=(const map&amp; mp); // = 重载赋值

map&lt;int, int&gt; m3;
m3.insert( pair&lt;type, type&gt;(elem, elem) ); // 插入一个pair值，会根据key值进行自动排序
</code></pre>
<h4 id="3-8-3-map大小和交换"><a href="#3-8-3-map大小和交换" class="headerlink" title="3.8.3 map大小和交换"></a>3.8.3 map大小和交换</h4><pre><code>size(); // 返回容器中的元素个数
empty(); // 判断容器是否为空
swap(); // 交换两个map中的元素
</code></pre>
<h4 id="3-8-4-插入和删除"><a href="#3-8-4-插入和删除" class="headerlink" title="3.8.4 插入和删除"></a>3.8.4 插入和删除</h4><pre><code>insert(elem); // 在容器中插入元素
map&lt;int, int&gt; m1;
// 第一种
m1.insert( pair&lt;type, type&gt;(elem, elem) ); // 插入一个pair值，会根据key值进行自动排序
// 第二种
m1.insert( make_pair(elem, elem) ); // 推荐
// 第三种
m1.insert(map&lt;int, int&gt;::value_type(elem, elem));
// 第四种
m1[4] = 40; // 用中括号直接赋值, 中括号中的数据是key的值，40是value
// 可以利用中括号通过key来访问value，这是中括号的主要用途


clear(); // 清除容器的元素
erase(pos); // 删除pos迭代器指向的元素，返回下一个元素的迭代器
erase(begin, end); // 删除区间中的元素，返回下一个元素的迭代器
erase(key); // 删除容器中的值为key的元素
</code></pre>
<h4 id="3-8-5-查找和统计"><a href="#3-8-5-查找和统计" class="headerlink" title="3.8.5 查找和统计"></a>3.8.5 查找和统计</h4><pre><code>find(key); // 按照key查找数据，若存在，返回该元素的迭代器，若不存在，返回map.end();
count(key); // 按照key统计元素个数，map因为不能加入重复的key，因此要么返回1，要么返回0
// multimap 要么返回0，要么返回相同的key的个数
</code></pre>
<h4 id="3-8-6-排序"><a href="#3-8-6-排序" class="headerlink" title="3.8.6 排序"></a>3.8.6 排序</h4><p>map容器默认排序规则为按照key的值进行从小到大排序，掌握如何利用仿函数改变排序规则</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;

class MyCompare &#123;

public:
    bool operator()(int v1, int v2)const &#123;
        return v1 &gt; v2;
    &#125;
&#125;;

void test01() &#123;
    map&lt;int, int, MyCompare&gt; m1;
    m1.insert(make_pair(1, 100));
    m1.insert(make_pair(2, 200));
    m1.insert(make_pair(3, 300));
    m1.insert(make_pair(4, 400));

    for (map&lt;int, int&gt;::iterator it = m1.begin(); it != m1.end(); it++)
    &#123;
        cout &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();

&#125;
</code></pre>
<h3 id="3-9-STL案列2-员工分组"><a href="#3-9-STL案列2-员工分组" class="headerlink" title="3.9 STL案列2-员工分组"></a>3.9 STL案列2-员工分组</h3><p>案例描述：</p>
<ol>
<li> 公司招聘了10个员工（a, b, c, d, e, f, g, h, i），10名员工进入公司之后，需要指派员工在哪个部门工作</li>
<li> 员工信息：姓名、工资组成</li>
<li> 部门分为：策划、美术、研发</li>
<li> 随机给10名员工分配部门和工资</li>
<li> 通过multimap进行信息的插入 key（部门编号），value（员工）</li>
<li> 分部门显示员工信息</li>
</ol>
<p>步骤：</p>
<ol>
<li>创建10名员工，放入vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将部门编号作为key，具体工作为value，放入到multimap中</li>
<li>分部门显示员工信息</li>
</ol>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;ctime&gt; // 
using namespace std;

class Department &#123;
public:
    int deptId;
    string deptName;

    Department()&#123;&#125;

    Department(int id) &#123;
        this-&gt;deptId = id;
        if (this-&gt;deptId == 1)
        &#123;
            this-&gt;deptName = &quot;策划部&quot;;
        &#125;
        else if (this-&gt;deptId == 2)
        &#123;
            this-&gt;deptName = &quot;美术部&quot;;
        &#125;
        else
        &#123;
            this-&gt;deptName = &quot;研发部&quot;;
        &#125;
    &#125;
&#125;;

class Employee &#123;
public:
    string m_name;
    int m_sal;
    Department dept;

    Employee(string name, int sal, Department dept)&#123;
        this-&gt;m_name = name;
        this-&gt;m_sal = sal;
        this-&gt;dept = dept;
    &#125;
&#125;;

void creacreateEmployee(vector&lt;Employee&gt;&amp; employeeVector) &#123;
    string employeeId = &quot;ABCDEFGHI&quot;;
    string name;
    int sal;
    int deptId;
    for (int i = 0; i &lt; employeeId.size(); i++)
    &#123;    
        name = &quot;员工：&quot;;
        name += employeeId[i]; // 字符串 += 字符，这样拼接成字符串
        sal = rand() % 10000 + 10000;
        deptId = rand() % 3 + 1;
        Department dept(deptId);
        Employee employee(name, sal, dept);
        employeeVector.push_back(employee);
    &#125;
&#125;

void insertEmployeeToMultimap(multimap&lt;int, Employee&gt;&amp; multimapEmployee,const vector&lt;Employee&gt;&amp; employeeVector) &#123;
    for (vector&lt;Employee&gt;::const_iterator it = employeeVector.begin(); it != employeeVector.end(); it++)
    &#123;
        multimapEmployee.insert(make_pair((*it).dept.deptId,(*it)));
    &#125;
&#125;

void test01() &#123;
    // 创建员工vector,用来存放员工
    vector&lt;Employee&gt; employeeVector;
    // 在这个函数中创建10个员工，并放入employeeVector中
    creacreateEmployee(employeeVector);

    // 根据员工的部门编号分组，将员工分别输入不同的部门
    multimap&lt;int, Employee&gt; multimapEmployee;

    // 将employeeVector中的员工加入 multimapEmployee
    insertEmployeeToMultimap(multimapEmployee, employeeVector);

    // 分部门显示员工信息
    multimap&lt;int, Employee&gt;::iterator it = multimapEmployee.begin();
    for (int i = 1; i &lt;= 3; i++) // i 表示部门号
    &#123;    
        switch (i)
        &#123;
            case 1: cout &lt;&lt; &quot;============策划部============&quot; &lt;&lt; endl; break;
            case 2: cout &lt;&lt; &quot;============美术部============&quot; &lt;&lt; endl; break;
            case 3: cout &lt;&lt; &quot;============研发部============&quot; &lt;&lt; endl; break;
        &#125;

        for (int j = 1; j &lt;= multimapEmployee.count(i); j++) // count(i) 表示 部门 i 有多少员工
        &#123;
            cout &lt;&lt; (*it).first &lt;&lt; &quot;\t\t&quot; &lt;&lt; (*it).second.m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it).second.m_sal &lt;&lt; endl;
            it++;
        &#125;
    &#125;
&#125;

int main() &#123;
    srand((unsigned int)time(NULL));
    test01();
&#125;
</code></pre>
<h2 id="第四章-STL函数对象"><a href="#第四章-STL函数对象" class="headerlink" title="第四章 STL函数对象"></a>第四章 STL函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象的概念"><a href="#4-1-1-函数对象的概念" class="headerlink" title="4.1.1 函数对象的概念"></a>4.1.1 函数对象的概念</h4><ol>
<li>重载 <strong>函数调用操作符</strong> 的类，其对象称为函数对象</li>
<li>函数对象使用重载的 () 时，行为类似函数调用，也叫 <strong>仿函数</strong></li>
<li>函数对象（仿函数）是一个类，不是一个函数</li>
</ol>
<h4 id="4-1-2-函数对象的使用"><a href="#4-1-2-函数对象的使用" class="headerlink" title="4.1.2 函数对象的使用"></a>4.1.2 函数对象的使用</h4><ol>
<li><p>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</p>
</li>
<li><p>函数对象超出普通函数的概念，函数对象可以有自己的状态</p>
</li>
<li><p>函数对象可以作为参数传递</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class MyAdd &#123;
public:
    int operator()(int v1, int v2) &#123;
        return v1 + v2;
    &#125;

    int count;

    void setCount(int a) &#123;
        this-&gt;count = a;
    &#125;

    int getCount() &#123;
        return this-&gt;count;
    &#125;

&#125;;

// 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
void test01() &#123;
    MyAdd myAdd;
    cout &lt;&lt; myAdd(10, 20) &lt;&lt; endl;
&#125;

// 函数对象超出普通函数的概念，函数对象可以有自己的状态
void test02() &#123;
    MyAdd myAdd;
    myAdd.setCount(90);
    cout &lt;&lt; myAdd.getCount() &lt;&lt; endl;
&#125;

// 函数对象可以作为参数传递
void printMyAdd(MyAdd&amp; myAdd) &#123;
    cout &lt;&lt; myAdd(20, 30) &lt;&lt; endl;
&#125;

void test03() &#123;
    MyAdd myAdd;
    printMyAdd(myAdd);
&#125;

int main() &#123;
    test01();
    test02();
    test03();
&#125;
</code></pre>
</li>
</ol>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2 谓词"></a>4.2 谓词</h3><h4 id="4-2-1-谓词的概念"><a href="#4-2-1-谓词的概念" class="headerlink" title="4.2.1 谓词的概念"></a>4.2.1 谓词的概念</h4><ol>
<li>返回 bool类型 的 仿函数 称为谓词</li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ol>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a><strong>4.2.2 一元谓词</strong></h4><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

class GreateFive &#123;
public:
    bool operator()(int value) &#123; // 返回 bool类型 的 仿函数 称为谓词,如果operator()接受一个参数，那么叫做一元谓词
        return value &gt; 5;
    &#125;
&#125;;

void test01() &#123;
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v.push_back(i);
    &#125;
    // 查找 v 中是否有大于 5 的值
    // GreateFive(),是匿名对象，且调用了重载()仿函数
    // 该函数返回的是满足 GreateFive()条件的迭代器
    // 若不满足，则返回 v.end()
    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreateFive()); 
    // 判断是否找到了大于5的数字
    if (it == v.end())
    &#123;
        cout &lt;&lt; &quot;未找到大于 5 的数字&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;找到了大于5的数字&quot; &lt;&lt; (*it) &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

class MyCompare &#123;
public:
    bool operator()(int v1, int v2) &#123;
        return v1 &gt; v2;
    &#125;
&#125;;

void test01() &#123;
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);

    // 该sort排序在 #include&lt;algorithm&gt; 中
    // 该排序默认是升序排序
    sort(v.begin(), v.end()); 
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;

    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl;

    // 使用sort的重载和仿函数，修改排序规则
    sort(v.begin(), v.end(), MyCompare());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象的意义"><a href="#4-3-1-内建函数对象的意义" class="headerlink" title="4.3.1 内建函数对象的意义"></a>4.3.1 内建函数对象的意义</h4><ol>
<li>STL内建了一些函数对象</li>
<li>分类：算术仿函数、关系仿函数、逻辑仿函数</li>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 #include<functional></li>
</ol>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><ol>
<li><p>实现四则运算</p>
</li>
<li><p>其中negate是一元运算，其他都是二元运算</p>
</li>
<li><p>仿函数原型：</p>
<pre><code>template&lt;class T&gt; T plus&lt;T&gt; // 加法仿函数
template&lt;class T&gt; T minus&lt;T&gt; // 减法仿函数
template&lt;class T&gt; T multiplies&lt;T&gt; // 乘法仿函数
template&lt;class T&gt; T divides&lt;T&gt; // 除法仿函数
template&lt;class T&gt; T modulus&lt;T&gt; // 取模仿函数
template&lt;class T&gt; T negate&lt;T&gt; // 取反仿函数
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;

void test01() &#123;
    // 算术仿函数，一元运算
    negate&lt;int&gt; n;
    cout &lt;&lt; n(50) &lt;&lt; endl; // negate 模板是对一个数取反运算

    // 二元加法运算
    plus&lt;int&gt; p; // 不允许对两个不同类型的数据做加法运算
    cout &lt;&lt; p(10, 29) &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p>实现对比关系</p>
<pre><code>template&lt;class T&gt; bool equal_to&lt;T&gt; // 等于
template&lt;class T&gt; bool not_equal_to&lt;T&gt; // 不等于
template&lt;class T&gt; bool greater&lt;T&gt; // 大于
template&lt;class T&gt; bool greater_equal&lt;T&gt; // 大于等于
template&lt;class T&gt; bool less&lt;T&gt; // 小于
template&lt;class T&gt; bool less_equal&lt;T&gt; // 小于等于
</code></pre>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;

void test01() &#123;
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);

    // 该sort排序在 #include&lt;algorithm&gt; 中
    // 该排序默认是升序排序
    sort(v.begin(), v.end());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;

    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; endl;

    // 使用sort的重载和仿函数，修改排序规则
    // 用内建函数对象来修改排序规则
    sort(v.begin(), v.end(), greater&lt;int&gt;());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p>实现逻辑运算</p>
<pre><code>template&lt;class T&gt; bool logical_and&lt;T&gt; // 逻辑与
template&lt;class T&gt; bool logical_not&lt;T&gt; // 逻辑非
template&lt;class T&gt; bool logical_or&lt;T&gt; // 逻辑或
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;functional&gt;
using namespace std;

void test01() &#123;
    vector&lt;bool&gt; v;
    v.push_back(true);
    v.push_back(false);
    v.push_back(true);
    v.push_back(false);

    for (vector&lt;bool&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;

    cout &lt;&lt; endl;

    // 使用内建函数对象做取反操作
    vector&lt;bool&gt; v1;
    v1.resize(v.size());

    transform(v.begin(), v.end(), v1.begin(), logical_not&lt;bool&gt;());
    for (vector&lt;bool&gt;::iterator it = v1.begin(); it != v1.end(); it++)
    &#123;
        cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;
    &#125;

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h2 id="第五章-常用算法"><a href="#第五章-常用算法" class="headerlink" title="第五章 常用算法"></a>第五章 常用算法</h2><ol>
<li>算法主要是由头文件<algorithm>, <functional>, <numeric> 组成</li>
<li><algorithm> 是所有STL头文件中的最大的一个，范围设计到比较，交换，查找，遍历操作，复制，修改等等</li>
<li><numeric> 体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><functional> 定义了一些模板类，用以声明函数对象</li>
</ol>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><ol>
<li><p>遍历容器</p>
</li>
<li><p>需要包含#include<algorithm></p>
</li>
<li><pre><code>for_each(iterator begin, iterator end, _func);
// begin 开始迭代器
// end 结束迭代器
// _func 普通函数或者函数对象
</code></pre>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

void print01(int value) &#123;
    cout &lt;&lt; value &lt;&lt;&quot; &quot;;
&#125;

class Print02 &#123;
public:
    void operator()(int value) &#123;
        cout &lt;&lt; value &lt;&lt; &quot; &quot; &lt;&lt; endl;
    &#125;
&#125;;

void test01() &#123;
    vector&lt;int&gt; v;
    v.push_back(20);
    v.push_back(10);
    v.push_back(40);
    v.push_back(30);
    v.push_back(50);

    for_each(v.begin(), v.end(), print01); // 普通函数，不加括号

    cout &lt;&lt; endl;

    for_each(v.begin(), v.end(), Print02()); // 如果是函数对象，需要将匿名对象传入

&#125;


int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><ol>
<li><p>搬运容器到另一个容器中</p>
</li>
<li><pre><code>transform(iteraotr begin1, iterator end1, iterator begin2, _func); // 容器元素的搬运，可以定义如何搬运
// begin1, 原容器的开始迭代器
// end1, 原容器的结束迭代器
// begin2, 目标容器的开始迭代器
// _func, 普通函数或者函数对象
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

class Transform01 &#123;
public:
    int operator()(int value) &#123;
        return value;
    &#125;
&#125;;

class Print01 &#123;
public:
    void operator()(int value) &#123;
        cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01() &#123;
    // 将 v1 中的元素搬运到 v2
    vector&lt;int&gt; v1;
    
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
    &#125;
    
    vector&lt;int&gt; v2;
    v2.resize(v1.size()); // 在搬运之前需要先指定v2的大小
    transform(v1.begin(), v1.end(), v2.begin(), Transform01());
    for_each(v2.begin(), v2.end(), Print01());

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h3 id="5-2-常用的查找算法"><a href="#5-2-常用的查找算法" class="headerlink" title="5.2 常用的查找算法"></a>5.2 常用的查找算法</h3><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><pre><code>// 查找value这个元素, 找到返回指定元素的迭代器，找不到返回结束迭代器end()
// 需要包含algorithm
find(iterator begin, iterator end, value);
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

class Person &#123;
public:
    string m_name;
    int m_age;

    Person(string name, int age) &#123;
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    &#125;

    bool operator==(const Person&amp; person) &#123;
        if (this-&gt;m_name == person.m_name &amp;&amp; this-&gt;m_age == person.m_age)
        &#123;
            return true;
        &#125;
        else
        &#123;
            return false;
        &#125;
    &#125;
&#125;;

void test01() &#123;
    Person person01(&quot;tom&quot;, 19);
    Person person02(&quot;jerry&quot;, 29);
    Person person03(&quot;smith&quot;, 9);
    Person person04(&quot;marry&quot;, 49);

    vector&lt;Person&gt; persons;

    persons.push_back(person01);
    persons.push_back(person02);
    persons.push_back(person03);
    persons.push_back(person04);
    
    // 查找
    // 查看find源码，得出需要重载 == 运算符修改对 相等 的定义
    // 因此底层不知道如何比较自定义数据类型
    vector&lt;Person&gt;::iterator it = find(persons.begin(), persons.end(), person02);
    if (it != persons.end())
    &#123;
        cout &lt;&lt; (*it).m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it).m_age &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;没有找到person02&quot; &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p>按条件查找元素，找到返回指定位置的迭代器，找不到返回结束迭代器位置</p>
<p>需要包含头文件：algorithm</p>
<pre><code>find_if(iterator begin, iterator end, _Pred); 
// begin 开始迭代器
// end 结束迭代器
// _Pred 普通函数或者谓词（返回bool类型的仿函数）
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

class Person &#123;
public:
    string m_name;
    int m_age;

    Person(string name, int age) &#123;
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    &#125;
&#125;;

class Greater20 &#123;
public:
    bool operator()(Person&amp; person) &#123;
        if (person.m_age &gt; 20)
        &#123;
            return true;
        &#125;
        else
        &#123;
            return false;
        &#125;
    &#125;
&#125;;

void test02() &#123;
    Person person01(&quot;tom&quot;, 19);
    Person person02(&quot;jerry&quot;, 29);
    Person person03(&quot;smith&quot;, 9);
    Person person04(&quot;marry&quot;, 49);

    vector&lt;Person&gt; persons;

    persons.push_back(person01);
    persons.push_back(person02);
    persons.push_back(person03);
    persons.push_back(person04);

    // 查找persons容器中，是否有年龄大于20的人
    vector&lt;Person&gt;::iterator it = find_if(persons.begin(), persons.end(), Greater20());
    if (it != persons.end())
    &#123;
        cout &lt;&lt; (*it).m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it).m_age &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;没有找到这样的人&quot; &lt;&lt; endl;
    &#125;

&#125;

int main() &#123;
    test02();
&#125;
</code></pre>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><pre><code>adjacent_find(iterator begin, iterator end); // 返回相邻重复元素的迭代器
</code></pre>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p>查找指定的元素是否存在，查到则返回true，否则返回false</p>
<pre><code>bool binary_search(iterator begin, iterator end, value);
// 注意，在无序序列中不可用
// 因为该算法基于二分查找法，速度比较快
// begin, 开始迭代器
// end, 结束迭代器
// value, 要查找的元素
</code></pre>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p>统计元素个数</p>
<pre><code>count(iterator begin, iterator end, value); // 在迭代器区间统计value的个数
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

class Person &#123;
public:
    string m_name;
    int m_age;

    Person(string name, int age) &#123;
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    &#125;

    bool operator==(const Person&amp; person) &#123;
        if (this-&gt;m_name == person.m_name &amp;&amp; this-&gt;m_age == person.m_age)
        &#123;
            return true;
        &#125;
        else
        &#123;
            return false;
        &#125;
    &#125;
&#125;;

void test01() &#123;
    Person person01(&quot;tom&quot;, 19);
    Person person02(&quot;jerry&quot;, 29);
    Person person03(&quot;smith&quot;, 9);
    Person person04(&quot;marry&quot;, 49);
    Person person05(&quot;jerry&quot;, 29);


    vector&lt;Person&gt; persons;

    persons.push_back(person01);
    persons.push_back(person02);
    persons.push_back(person03);
    persons.push_back(person04);
    persons.push_back(person05);
    
    int num;
    // 统计自定义数据类型的个数，需要重载运算符 == 
    num = count(persons.begin(), persons.end(), person02);
    cout &lt;&lt; num &lt;&lt; endl;
&#125;

int main() &#123;
    test01();

&#125;
</code></pre>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p>按条件统计某个元素个数</p>
<pre><code>count_if(iterator begin, iterator end, _Pred);
// begin 开始迭代器
// end 结束迭代器
// _Pred 谓词，返回 bool类型 的 仿函数 称为谓词，函数对象
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

class Person &#123;
public:
    string m_name;
    int m_age;

    Person(string name, int age) &#123;
        this-&gt;m_name = name;
        this-&gt;m_age = age;
    &#125;

&#125;;

class age20 &#123;
public:
    bool operator()(const Person&amp; person) &#123;
        return person.m_age &gt; 20;
    &#125;
&#125;;

void test01() &#123;
    Person person01(&quot;tom&quot;, 19);
    Person person02(&quot;jerry&quot;, 29);
    Person person03(&quot;smith&quot;, 9);
    Person person04(&quot;marry&quot;, 49);
    Person person05(&quot;tom&quot;, 89);


    vector&lt;Person&gt; persons;

    persons.push_back(person01);
    persons.push_back(person02);
    persons.push_back(person03);
    persons.push_back(person04);
    persons.push_back(person05);
    
    int num;
    // 统计自定义数据类型的个数，需要重载运算符 == 
    // 统计年龄大于二十的人数
    num = count_if(persons.begin(), persons.end(),age20());
    cout &lt;&lt; num &lt;&lt; endl;
&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><pre><code>// 对容器元素进行排序
sort(iterator begin, iterator end, _Pred);
// _Pred 谓词，可以改变排序规则
</code></pre>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p>#include<algorithm></p>
<pre><code>// 洗牌算法，将指定范围内的元素顺序打乱
random_shuffle(iterator begin, iterator end);
</code></pre>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p>#include<algorithm></p>
<p>两个容器中的元素合并，并存储到另一个容器（需要提前开辟空间）中</p>
<pre><code>merge(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator dest);
// 注意，两个容器必须是有序的
// dest 目标容器的开始迭代器
// 合并以后依然是一个有序序列
</code></pre>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><pre><code>// 将容器内的元素进行反转
reverse(iterator begin, iterator end);
</code></pre>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p>#include<algorithm></p>
<p>其实，在vector容器中直接用 = 赋值即可</p>
<pre><code>// 容器内指定范围的元素拷贝到另一个容器(需要提前开辟空间，否则无法加入数据)中
copy(iterator begin, iterator end, iterator dest);
// 将区间内的元素拷贝到另一个容器的dest迭代器
</code></pre>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p>将容器内的指定范围的旧元素替换为新元素</p>
<p>#include<algorithm></p>
<pre><code>replace(iterator begin, iterator end, elem1, elem2); // 将区间的元素的elem1全部替换为elem2 
</code></pre>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p>将区间内满足条件的元素替换为新元素</p>
<p>#include<algorithm></p>
<pre><code>replace_if(iterator begin, iterator end, _Pred, newElem);
// _Pred 谓词
// newElem 新的元素
</code></pre>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><pre><code>// 交换两个容器中的元素
swap(container c1, container c2); // 两个容器中类型要相同
</code></pre>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p>#include<numeric></p>
<pre><code>accumulate(iterator begin, iterator end, value); // 将容器中的元素累加并返回总和
// value 是起始的累加值
</code></pre>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p>#include<numeric></p>
<p>向容器区间填充指定的数据</p>
<pre><code>fill(iterator begin, iterator end, value); // 将value填充到区间
</code></pre>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p>求两个容器（这两个容器必须都是有序的）的交集，这个交集要放在另一个容器（要提前开辟空间），这两个容器都必须是同一种类型</p>
<pre><code>set_intersection(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator newBegin); 
// 返回的是 交集的最后一个元素的下一个位置的迭代器
</code></pre>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p>求两个容器（这两个容器必须是有序的）的并集，然后将并集放入新的容器（要提前开辟空间）</p>
<pre><code>set_union(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator newBegin);
// 返回的是的并集的最后一个元素的下一个位置的迭代器;
</code></pre>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3 set_difference"></a>5.6.3 set_difference</h4><p>求两个容器（这两个容器必须是有序的）的差集，并将差集放到新的容器</p>
<p>要明确 谁和谁的差集，这是有区别的</p>
<ol>
<li>v1 和 v2 容器的差集<ol start="2">
<li>v2 和 v1 容器的差集</li>
</ol>
</li>
</ol>
<pre><code>set_difference(iterator begin1, iterator end1, iterator begin2, iterator end2, iterator newBegin);
// 返回的是差集的最后一个元素的下一个位置的迭代器
</code></pre>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h4 id="生成随机数："><a href="#生成随机数：" class="headerlink" title="生成随机数："></a><strong>生成随机数：</strong></h4><p>​    // 添加随机数种子：利用系统的当前时间生成随机数，防止每次随机数都一样</p>
<p>​    srand((unsigned int)time(NULL));  // 要包含 #include<ctime><br>​    // 生成一个随机数<br>​    int randomNum = 1 + rand() % 100;<br>​    cout &lt;&lt; randomNum &lt;&lt; endl;</p>
<h4 id="常用计算方法："><a href="#常用计算方法：" class="headerlink" title="常用计算方法："></a><strong>常用计算方法：</strong></h4><p>​    a = num % 10; // 获取个位<br>​    b = (num / 10) % 10; // 获取十位<br>​    c = num / 100; // 获取百位</p>
<h4 id="列数小于等于行数"><a href="#列数小于等于行数" class="headerlink" title="列数小于等于行数"></a><strong>列数小于等于行数</strong></h4><p>sizeof(数据):统计数据所占的字节数</p>
<p>system(“pause”); // 请按任意键继续</p>
<h4 id="include"><a href="#include" class="headerlink" title="#include"></a><strong>#include<algorithm></strong></h4><p>find_if(迭代器开始，迭代器结束，匿名对象())； // 匿名对象()，使用了重载的()运算符</p>
<h4 id="min-elem-elem-；求最小值"><a href="#min-elem-elem-；求最小值" class="headerlink" title="min(elem, elem)；求最小值"></a>min(elem, elem)；求最小值</h4><h4 id="max-elem-elem-；求最大值"><a href="#max-elem-elem-；求最大值" class="headerlink" title="max(elem, elem)；求最大值"></a>max(elem, elem)；求最大值</h4><h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><p>头文件中写声明；</p>
<p>源文件中写实现；</p>
<p>#progma once：防止头文件重复包含</p>
<p>类名::   意思是声明作用域</p>
<p>shift + tab 向右缩进</p>
<p><strong>匿名对象：</strong>类名()。使用完后就会被释放</p>
<p><strong>开闭原则：</strong>对扩展进行开放，对修改进行关闭</p>
<h1 id="经典习题"><a href="#经典习题" class="headerlink" title="经典习题"></a>经典习题</h1><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><pre class=" language-c++"><code class="language-c++">#include<iostream>
using namespace std;
int main() &#123;
    // 冒泡排序：从小到大排序
    int arr[] = &#123;5,4,3,2,1&#125;;
    int temp = 0;
    for (int i = 0; i < sizeof(arr)/sizeof(int) - 1; i++) // 执行几次冒泡排序
    &#123;
        for (int j = 0; j < sizeof(arr)/sizeof(int) - i - 1; j++)
        &#123;
            // 交换数据
            if (arr[j] > arr[j + 1]) &#123;
                temp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    for (int i = 0; i < sizeof(arr)/sizeof(int); i++)
    &#123;
        cout << arr[i] << "\t";
    &#125;
&#125;
// 比较相邻元素，如果第一个数字比第二个数字大，则交换
// 要执行多少次冒泡排序（数组长度-1）次
// 每轮对比次数 = 元素个数 - 排序轮数 - 1
</code></pre>
<h4 id="冒泡排序升级：用指针、数组、函数"><a href="#冒泡排序升级：用指针、数组、函数" class="headerlink" title="冒泡排序升级：用指针、数组、函数"></a>冒泡排序升级：用指针、数组、函数</h4><pre><code>#include&lt;iostream&gt;
using namespace std;

// 从小到大排序
// 传入的是数组首地址，那么形参arr的地址就是实参的地址，形参arr数据的修改其实就是修改的实参的数据
void bubbleSort(int * arr, int length) &#123;
    int temp = 0;
    for (int i = 0; i &lt; length - 1; i++)
    &#123;
        for (int j = 0; j &lt; length - i - 1; j++)
        &#123;
            // 交换数据
            if (arr[j] &gt; arr[j + 1]) &#123;
                temp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
&#125;

int main() &#123;
    // 创建数组
    int arr[] = &#123;3, 4, 9, 2, 0, -1&#125;;
    int* p = arr;
    cout &lt;&lt; *p &lt;&lt; &quot;的地址是：&quot; &lt;&lt; p &lt;&lt; endl; // 3的地址是：000000A877F6FB98
    cout &lt;&lt; *p++ &lt;&lt; &quot;的地址是：&quot; &lt;&lt; p &lt;&lt; endl; // 3的地址是：000000A877F6FB9C
    // 获取数组的长度
    int length = sizeof(arr) / sizeof(int);
    // 调用冒泡排序算法
    bubbleSort(arr, length);
    // 打印排序结果
    for (int i = 0; i &lt; length; i++)
    &#123;
        cout &lt;&lt; arr[i] &lt;&lt; &quot;\t&quot;;
    &#125;
    return 0;
&#125;
</code></pre>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="职工管理系统"><a href="#职工管理系统" class="headerlink" title="职工管理系统"></a>职工管理系统</h2><h4 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&quot;WorkerManager.h&quot;
#include&quot;Worker.h&quot;
#include&quot;Employee.h&quot;
#include&quot;Boos.h&quot;
#include&quot;Manager.h&quot;

int main() &#123;
    WorkerManager workerManager;
    int choice = 0; // 用户的选项

    while (true)
    &#123;
        workerManager.show_Menu(); // 循环展示菜单栏
        cout &lt;&lt; &quot;请输入要执行的功能：&quot;;
        cin &gt;&gt; choice; // 接收用户的选择

        switch (choice)
        &#123;
        case 0: 
            // 程序退出
            workerManager.exitSystem();
            break;
        case 1:
            // 添加职工信息
            workerManager.addWorker();
            break;
        case 2:
            // 显示职工信息
            workerManager.showWorkers();
            break;
        case 3:
            // 删除离职职工
            workerManager.deleteWorker();
            break;
        case 4:
            // 修改职工信息
            workerManager.modifyWorkerInfo();
            break;
        case 5:
            // 查找职工信息
            workerManager.findWorkerById();
            break;
        case 6:
            // 按照编号排序
            workerManager.ascendingSort();
            break;
        case 7:
            // 清空职工信息
            workerManager.cleanFile();
            break;
        default:
            system(&quot;cls&quot;); // 清屏
            break;
        &#125;
    &#125;
    system(&quot;pause&quot;);
&#125;
</code></pre>
<h4 id="职员管理-h文件"><a href="#职员管理-h文件" class="headerlink" title="职员管理.h文件"></a>职员管理.h文件</h4><pre><code>#pragma once // 防止头文件重复包含
#include&lt;iostream&gt; // 标准文件输入输出流
using namespace std; // 标准命名空间
#include&quot;Worker.h&quot;

class WorkerManager &#123;
public:
    int workerNum; // 该职工管理系统中的职工数
    Worker** workers; // 职工管理系统中指向职工数组的指针
    bool fileIsEmpty;


    // 在头文件中声明，在源文件中实现
    WorkerManager();
    ~WorkerManager();

    // 与用户沟通的界面
    void show_Menu();

    // 退出功能
    void exitSystem();

    void addWorker();

    void saveToFile(string filePath);

    // 统计该系统中的职工数
    int getWorkerNum();

    // 初始化员工
    void initWorker();

    // 显示该系统中职工信息
    void showWorkers();

    // 根据职工id删除职工
    void deleteWorker();

    // 根据职工id修改职工数据
    void modifyWorkerInfo();

    // 根据职工id查找职工数据
    void findWorkerById();

    // 按照职工id升序排序
    void ascendingSort();

    // 清空文件
    void cleanFile();
&#125;;
</code></pre>
<h4 id="职员管理-cpp文件"><a href="#职员管理-cpp文件" class="headerlink" title="职员管理.cpp文件"></a>职员管理.cpp文件</h4><pre><code>#include&lt;iostream&gt;
#include&quot;WorkerManager.h&quot;
using namespace std;
#include&lt;string&gt;
#include&quot;Boos.h&quot;
#include&quot;Employee.h&quot;
#include&quot;Manager.h&quot;
#include&lt;fstream&gt;
#define FILEPATH &quot;workersTable.txt&quot;

WorkerManager::WorkerManager() &#123;
    // 1. 文件不存在
    ifstream ifs;
    ifs.open(FILEPATH, ios::in);
    if (!ifs.is_open()) &#123;
        cout &lt;&lt; &quot;文件不存在,文件打开失败&quot; &lt;&lt; endl;
        this-&gt;workerNum = 0;
        this-&gt;workers = NULL;
        this-&gt;fileIsEmpty = true;
        ifs.close();
        return;
    &#125;
    // 2. 文件存在，但文件没有数据
    char ch;
    ifs &gt;&gt; ch; // 把文件的第一个字符读到ch中
    if (ifs.eof()) &#123; // eof()函数可以帮助我们用来判断文件是否为空，抑或是判断其是否读到文件结尾
        // 文件为空
        cout &lt;&lt; &quot;文件为空&quot; &lt;&lt; endl;
        this-&gt;workerNum = 0;
        this-&gt;workers = NULL;
        this-&gt;fileIsEmpty = true;
        ifs.close();
        return;
    &#125;
    // 3. 文件存在，并且也有数据
    int num = this-&gt;getWorkerNum();
    this-&gt;workerNum = num;
    cout &lt;&lt; &quot;当前职工人数为：&quot; &lt;&lt; this-&gt;workerNum &lt;&lt; endl;
    // 将文件中的职工数据读入程序
    this-&gt;workers = new Worker * [this-&gt;workerNum];
    this-&gt;initWorker();

    for (int i = 0; i &lt; this-&gt;workerNum; i++)
    &#123;
        cout &lt;&lt; this-&gt;workers[i]-&gt;m_id &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;workers[i]-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;workers[i]-&gt;m_deptId &lt;&lt; endl;
    &#125;
&#125;

WorkerManager::~WorkerManager() &#123;
    if (this-&gt;workers != NULL) &#123;
        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            delete this-&gt;workers[i];
            this-&gt;workers[i] = NULL;
        &#125;

        delete[] this-&gt;workers;
        this-&gt;workers = NULL;
    &#125;
&#125;

// 用户管理系统菜单
void WorkerManager::show_Menu() &#123; // 返回类型 函数限定域::函数名
    cout &lt;&lt; &quot;**********************************************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;************ 欢迎使用职工管理系统 ************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  0.退出管理程序  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  1.增加职工信息  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  2.显示职工信息  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  3.删除离职职工  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  4.修改职工信息  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  5.查找职工信息  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  6.按照编号排序  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*************  7.清空职工信息  ***************&quot; &lt;&lt; endl;
    cout &lt;&lt; endl;
&#125;

void WorkerManager::exitSystem() &#123;
    cout &lt;&lt; &quot;系统退出，欢迎下次使用&quot; &lt;&lt; endl;
    system(&quot;pause&quot;);
    exit(0); // 程序退出
&#125;

void WorkerManager::addWorker() &#123;
    cout &lt;&lt; &quot;请输入你要添加的职工数：&quot;;
    int newWorkerNum = 0;
    cin &gt;&gt; newWorkerNum;

    if (newWorkerNum &gt; 0) &#123;
        int newSpaceSize = this-&gt;workerNum + newWorkerNum + 5;
        // 开辟新空间
        // 第一个 * 表示创建数组的类型是Worker存放指针类型数据的数组
        // 第二个 * 表示 new 运算符在堆区创建了数组，返回的是一个堆区数组的地址
        Worker** newSpace = new Worker*[newSpaceSize]; // 这是一个存放指针的数组，返回的是一个指针数组的地址

        // 将workers数组中原来的数据拷贝到新数组
        if (this-&gt;workers != NULL) &#123;
            for (int i = 0; i &lt; this-&gt;workerNum; i++)
            &#123;
                newSpace[i] = this-&gt;workers[i];
            &#125;
        &#125;

        // 将新职工加入新数组
        for (int i = 0; i &lt; newWorkerNum; i++)
        &#123;
            int id;
            string name;
            int deptId;
            
            cout &lt;&lt; &quot;请输入新增的第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;个员工的信息:&quot; &lt;&lt; endl;
            cout &lt;&lt; &quot;请输入职工编号：&quot;; cin &gt;&gt; id;
            cout &lt;&lt; &quot;请输入职工姓名：&quot;; cin &gt;&gt; name;
            cout &lt;&lt; &quot;请输入部门编号：&quot;; cin &gt;&gt; deptId;

            Worker* worker = NULL;
            switch (deptId)
            &#123;
            case 1:
                worker = new Employee(id, name, 1);
                break;
            case 2:
                worker = new Manager(id, name, 2);
                break;
            case 3:
                worker = new Boos(id, name, 3);
                break;
            default:
                cout &lt;&lt; &quot;部门编号输入有误&quot; &lt;&lt; endl;
                break;
            &#125;
            newSpace[this-&gt;workerNum + i] = worker;
        &#125;

        // 释放原来 this-&gt;workers 指向的堆区的内容
        delete[] this-&gt;workers;
        workers = NULL;
        // 更改新空间的指向
        this-&gt;workers = newSpace;
        newSpace = NULL;
        // 更新职工人数
        this-&gt;workerNum = newSpaceSize - 5;
        // 提示添加成功
        cout &lt;&lt; &quot;成功添加了&quot; &lt;&lt; newWorkerNum &lt;&lt; &quot;名职工&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;目前共有&quot; &lt;&lt; this-&gt;workerNum &lt;&lt; &quot;名职工&quot; &lt;&lt; endl;
    
        // 添加成功后把数据写入文件中
        this-&gt;saveToFile(FILEPATH);
        // 更改文件的状态
        this-&gt;fileIsEmpty = false;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;输入人数有误&quot; &lt;&lt; endl;
    &#125;
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

// 将职工信息存入文件
void WorkerManager::saveToFile(string filePath) &#123;
    ofstream ofs;
    ofs.open(filePath, ios::out);
    for (int i = 0; i &lt; this-&gt;workerNum; i++)
    &#123;
        ofs &lt;&lt; this-&gt;workers[i]-&gt;m_id &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;workers[i]-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;workers[i]-&gt;m_deptId &lt;&lt; endl;
    &#125;
    ofs.close();
&#125;

int WorkerManager::getWorkerNum() &#123;
    ifstream ifs;
    ifs.open(FILEPATH, ios::in);

    int id;
    string name;
    int deptId;

    int num = 0;
    while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; deptId)
    &#123;
        num++;
    &#125;
    ifs.close();
    return num;
&#125;

void WorkerManager::initWorker() &#123;
    // 读取文件，将职工数据读入程序
    ifstream ifs;
    ifs.open(FILEPATH, ios::in);

    int id;
    string name;
    int deptId;

    Worker* worker = NULL;
    int index = 0;

    while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; deptId) &#123;
        // 根据deptId，创建不同的职工对象,然后放入该系统维护的职工数组
        if (deptId == 1)
        &#123;
            worker = new Employee(id, name, 1);
        &#125;
        else if (deptId == 2)
        &#123;
            worker = new Manager(id, name, 2);
        &#125;
        else
        &#123;
            worker = new Boos(id, name, 3);
        &#125;
        this-&gt;workers[index] = worker;
        index++;
    &#125;

    ifs.close();
&#125;

void WorkerManager::showWorkers() &#123;
    // 首先可以判断文件是否为空
    if (this-&gt;fileIsEmpty)
    &#123;
        cout &lt;&lt; &quot;文件为空，该系统中没有职工&quot; &lt;&lt; endl;
    &#125;
    else // 否则将该系统中维护的职工数组信息进行输出展示
    &#123;
        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            // 可以利用多态来调用每个职工的showInfo()函数，来展示职工信息
            this-&gt;workers[i]-&gt;showInfo();
        &#125;
    &#125;
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

void WorkerManager::deleteWorker() &#123;
    // 首先判断文件是否为空
    if (this-&gt;fileIsEmpty)
    &#123;
        cout &lt;&lt; &quot;文件为空，无法执行删除操作&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;    
        // 根据输入的职工的id删除职工
        int id;
        cout &lt;&lt; &quot;请输入要输入职工的id：&quot;;
        cin &gt;&gt; id;

        // 查找要删除的职工
        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            if (id == this-&gt;workers[i]-&gt;m_id)
            &#123;    
                // 找到了要删除的职工，要将数组指向的职工内存内容删除
                delete this-&gt;workers[i];
                this-&gt;workers[i] = NULL;
                // 更新数组,将后面的职工在数组中前移
                // i 是要删除的职工在数组中的下标
                for (int j = i; i &lt; this-&gt;workerNum - 1; i++)
                &#123;
                    this-&gt;workers[i] = this-&gt;workers[i + 1];
                &#125;
                this-&gt;workerNum--; // 删除成功后，要将该系统的职工数减一

                // 更新文件
                this-&gt;saveToFile(FILEPATH);
                cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl;
                break;
            &#125;
            if (i == this-&gt;workerNum - 1)
            &#123;
                cout &lt;&lt; &quot;该系统中没有该职工，因此无法删除&quot; &lt;&lt; endl;
            &#125;
        &#125;
    &#125;
    system(&quot;pause&quot;); // 按任意键继续
    system(&quot;cls&quot;); // 清屏
&#125;

// 根据 id 修改职工信息
void WorkerManager::modifyWorkerInfo() &#123;
    if (this-&gt;fileIsEmpty)
    &#123;
        cout &lt;&lt; &quot;文件为空，无法修改职工信息&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        int id;
        cout &lt;&lt; &quot;请输入想要修改的职工的编号：&quot;;
        cin &gt;&gt; id;

        // 查找该职工
        int index = -1;
        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            if (id == this-&gt;workers[i]-&gt;m_id)
            &#123;    
                // 将查找到的职工对应的数组下标赋值给 index
                index = i;
                break;
            &#125;
        &#125;

        if (index != -1)
        &#123;
            delete this-&gt;workers[index];
            this-&gt;workers[index] = NULL;
            
            // 重修编写 该职工的信息
            int newId;
            string newName;
            int newDeptId;

            cout &lt;&lt; &quot;请重新输入要修改的职工的职工编号：&quot;; cin &gt;&gt; newId;
            cout &lt;&lt; &quot;请重新输入要修改的职工的姓名：&quot;; cin &gt;&gt; newName;
            cout &lt;&lt; &quot;请重新输入要修改的职工的部门编号：&quot;; cin &gt;&gt; newDeptId;

            Worker* worker = NULL;
            if (newDeptId == 1)
            &#123;
                // 普通员工
                worker = new Employee(newId, newName, 1);
            &#125;
            else if (newDeptId == 2)
            &#123;
                worker = new Manager(newId, newName, 2);
            &#125;
            else if (newDeptId == 3)
            &#123;
                worker = new Boos(newId, newName, 3);
            &#125;
            else
            &#123;
                cout &lt;&lt; &quot;输入的部门编号不合法，程序退出&quot; &lt;&lt; endl;

                return;
            &#125;
            this-&gt;workers[index] = worker;
            cout &lt;&lt; &quot;修改成功&quot; &lt;&lt; endl;
            // 保存到文件中
            this-&gt;saveToFile(FILEPATH);
        &#125;
        else
        &#123;
            cout &lt;&lt; &quot;查无此人，修改失败&quot; &lt;&lt; endl;
        &#125;
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
    &#125;

&#125;

// 根据 id 查找职工
void WorkerManager::findWorkerById() &#123;
    // 判断文件是否为空
    if (this-&gt;fileIsEmpty)
    &#123;
        cout &lt;&lt; &quot;文件为空，查找失败&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        // 文件不空，通过id进行查找
        cout &lt;&lt; &quot;请输入要查找的职工的id：&quot;;
        int id;
        cin &gt;&gt; id;
        int index = -1;
        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            if (id == this-&gt;workers[i]-&gt;m_id)
            &#123;
                // 该职工存在，则输出该职工的信息
                this-&gt;workers[i]-&gt;showInfo();
                index = i;
            &#125;
        &#125;
        if (index == -1)
        &#123;
            cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;
        &#125;
    &#125;
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

// 根据 id 升序排序
void WorkerManager::ascendingSort() &#123;
    // 判断文件是否为空
    if (this-&gt;fileIsEmpty)
    &#123;
        cout &lt;&lt; &quot;文件为空&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        // 选择升序排序
        int minIndex = 0;
        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            // 寻找 最小 id
            minIndex = i;
            for (int j = i + 1; j &lt; this-&gt;workerNum; j++)
            &#123;
                if (this-&gt;workers[minIndex]-&gt;m_id &gt; this-&gt;workers[j]-&gt;m_id)
                &#123;
                    minIndex = j;
                &#125;
            &#125;
            // 找到最小 id 进行交换
            if (minIndex != i)
            &#123;
                Worker* temp = NULL;
                temp = this-&gt;workers[minIndex];
                this-&gt;workers[minIndex] = this-&gt;workers[i];
                this-&gt;workers[i] = temp;
            &#125;
        &#125;
        this-&gt;saveToFile(FILEPATH);
    &#125;
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

// 清空文件
void WorkerManager::cleanFile() &#123;
    cout &lt;&lt; &quot;确定要清空文件吗？yes/no：&quot;;
    string flag;
    cin &gt;&gt; flag;

    if (flag == &quot;yes&quot;)
    &#123;
        // 则执行清空文件
        fstream fs;
        fs.open(FILEPATH, ios::trunc);
        fs.close();

        for (int i = 0; i &lt; this-&gt;workerNum; i++)
        &#123;
            if (this-&gt;workers[i] != NULL)
            &#123;
                delete this-&gt;workers[i];
                this-&gt;workers[i] = NULL;
            &#125;
        &#125;

        this-&gt;workerNum = 0;
        delete[] this-&gt;workers;
        this-&gt;workers = NULL;
        this-&gt;fileIsEmpty = true;
        cout &lt;&lt; &quot;文件清空成功&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        // 不执行清空文件操作
        cout &lt;&lt; &quot;清空文件不执行&quot; &lt;&lt; endl;
    &#125;
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;
</code></pre>
<h4 id="Employee-h文件"><a href="#Employee-h文件" class="headerlink" title="Employee.h文件"></a>Employee.h文件</h4><pre><code>#pragma once
#include&lt;iostream&gt;
using namespace std;
#include&quot;Worker.h&quot;

class Employee : public Worker &#123;

public:
    // 构造函数
    Employee(int id, string name, int deptId);

    // 子类实现父类的纯虚函数
    // 显示个人信息
     void showInfo();

    // 获取岗位名称
    void getDeptName();
    
&#125;;
</code></pre>
<h4 id="Employee-cpp文件"><a href="#Employee-cpp文件" class="headerlink" title="Employee.cpp文件"></a>Employee.cpp文件</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
#include&quot;Employee.h&quot;

Employee::Employee(int id, string name, int deptId) &#123;
    this-&gt;m_id = id;
    this-&gt;m_name = name;
    this-&gt;m_deptId = deptId;
&#125;

void Employee::showInfo() &#123;
    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_id &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;职工姓名：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;部门编号：&quot; &lt;&lt; this-&gt;m_deptId &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;岗位职责：完成经理下发的任务&quot; &lt;&lt; endl;
&#125;

void Employee::getDeptName() &#123;
    
&#125;
</code></pre>
<h4 id="Manager-h文件"><a href="#Manager-h文件" class="headerlink" title="Manager.h文件"></a>Manager.h文件</h4><pre><code>#pragma once
#include&quot;Worker.h&quot;
#include&lt;string&gt;

// 创建的头文件声明类
class Manager :public Worker &#123;

public:
    Manager(int id, string name, int deptId);
    
    void showInfo();

    void getDeptName();

&#125;;
</code></pre>
<h4 id="Manager-cpp文件"><a href="#Manager-cpp文件" class="headerlink" title="Manager.cpp文件"></a>Manager.cpp文件</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&quot;Manager.h&quot;

Manager::Manager(int id, string name, int deptId) &#123;
    this-&gt;m_id = id;
    this-&gt;m_name = name;
    this-&gt;m_deptId = deptId;
&#125;

void Manager::showInfo() &#123;
    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_id &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;职工姓名：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;部门编号：&quot; &lt;&lt; this-&gt;m_deptId &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;岗位职责：给员工分配老板下发的任务&quot; &lt;&lt; endl;
&#125;

void Manager::getDeptName() &#123;

&#125;
</code></pre>
<h4 id="Boos-h文件"><a href="#Boos-h文件" class="headerlink" title="Boos.h文件"></a>Boos.h文件</h4><pre><code>#pragma once
#include&quot;Worker.h&quot;
#include&lt;string&gt;

class Boos :public Worker &#123;
public:
    Boos(int id, string name, int deptId);

    void showInfo();
    void getDeptName();
&#125;;
</code></pre>
<h4 id="Boos-cpp文件"><a href="#Boos-cpp文件" class="headerlink" title="Boos.cpp文件"></a>Boos.cpp文件</h4><pre><code>#include&quot;Boos.h&quot;
using namespace std;

Boos::Boos(int id, string name, int deptId) &#123;
    this-&gt;m_id = id;
    this-&gt;m_name = name;
    this-&gt;m_deptId = deptId;
&#125;

void Boos::showInfo() &#123;
    cout &lt;&lt; &quot;职工编号：&quot; &lt;&lt; this-&gt;m_id &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;职工姓名：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;部门编号：&quot; &lt;&lt; this-&gt;m_deptId &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;岗位职责：我是老板&quot; &lt;&lt; endl;
&#125;

void Boos::getDeptName() &#123;

&#125;
</code></pre>
<h2 id="评委打分"><a href="#评委打分" class="headerlink" title="评委打分"></a>评委打分</h2><p>案例描述：有5名选手：ABCDE，10个评委分别对每一名选手打分，去除最高分，去除最低分，取平均分</p>
<p>实现步骤：</p>
<ol>
<li><p>创建5名选手，放入vector中</p>
</li>
<li><p>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分存到deque容器中</p>
</li>
<li><p>sort算法对deque容器中的分数排序，去除最高和最低分</p>
</li>
<li><p>deque容器遍历一遍，累加总分，求取平均分</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
using namespace std;

class Person &#123;
public:
    string m_id;
    deque&lt;int&gt; m_scores;
public:
    Person(string id) &#123;
        this-&gt;m_id = id;
    &#125;
&#125;;

void test01() &#123;
    // 创建 5名选手
    Person person01(&quot;01&quot;);
    Person person02(&quot;02&quot;);
    Person person03(&quot;03&quot;);
    Person person04(&quot;04&quot;);
    Person person05(&quot;05&quot;);

    // 将5名选手加入 vector 容器
    vector&lt;Person&gt; personVector;
    personVector.push_back(person01);
    personVector.push_back(person02);
    personVector.push_back(person03);
    personVector.push_back(person04);
    personVector.push_back(person05);

    // 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分存到deque容器中
    for (vector&lt;Person&gt;::iterator it = personVector.begin(); it != personVector.end(); it++)
    &#123;
        // 给每一个选手打分
        // 一共有10个评委
        for (int i = 0; i &lt; 10; i++)
        &#123;
            (*it).m_scores.push_back(i + 1);
        &#125;

        // 对评分进行排序
        sort((*it).m_scores.begin(), (*it).m_scores.end());

        (*it).m_scores.pop_front(); // 去掉最低分
        (*it).m_scores.pop_back(); // 去掉最高分


        // 求总分
        int sumScore = 0; // 总分
        for (deque&lt;int&gt;::iterator i = (*it).m_scores.begin(); i != (*it).m_scores.end(); i++) &#123;
            sumScore = sumScore + (*i);
        &#125;

        // 求平均分
        double avgScore = sumScore / 8.0;
        cout &lt;&lt; &quot;选手：&quot; &lt;&lt; (*it).m_id &lt;&lt; &quot;的最终得分为：&quot; &lt;&lt; avgScore &lt;&lt; endl;
    &#125;

&#125;

int main() &#123;
    test01();
&#125;
</code></pre>
</li>
</ol>
<h2 id="基于STL的演讲比赛流程管理系统"><a href="#基于STL的演讲比赛流程管理系统" class="headerlink" title="基于STL的演讲比赛流程管理系统"></a>基于STL的演讲比赛流程管理系统</h2><h4 id="myCompare-h"><a href="#myCompare-h" class="headerlink" title="myCompare.h"></a><strong>myCompare.h</strong></h4><pre><code>#pragma once
#include&quot;speaker.h&quot;

class MyCompare0 &#123;
public:
    bool operator()(const Speaker&amp; s1, const Speaker&amp; s2);
&#125;;

class MyCompare1 &#123;
public:
    bool operator()(const Speaker&amp; s1, const Speaker&amp; s2);
&#125;;
</code></pre>
<h4 id="myCompare-cpp"><a href="#myCompare-cpp" class="headerlink" title="myCompare.cpp"></a><strong>myCompare.cpp</strong></h4><pre><code>#include&quot;myCompare.h&quot;
#include&quot;speechManager.h&quot;

bool MyCompare0::operator()(const Speaker&amp; s1, const Speaker&amp; s2) &#123;
    return s1.m_score[0] &gt; s2.m_score[0];
&#125;

bool MyCompare1::operator()(const Speaker&amp; s1, const Speaker&amp; s2) &#123;
    return s1.m_score[1] &gt; s2.m_score[1];
&#125;
</code></pre>
<h4 id="speaker-h"><a href="#speaker-h" class="headerlink" title="speaker.h"></a><strong>speaker.h</strong></h4><pre><code>#pragma once
#include&lt;string&gt;
using namespace std;

class Speaker &#123;
public:
    string m_id; // 选手编号
    double m_score[2]; // 保存两轮的分数 
&#125;;
</code></pre>
<h4 id="speechManager-h"><a href="#speechManager-h" class="headerlink" title="speechManager.h"></a><strong>speechManager.h</strong></h4><pre><code>#pragma once
#include&lt;map&gt;
#include&lt;vector&gt;
#include&quot;speaker.h&quot;

class SpeechManager &#123;
public:
    // 声明构造函数
    SpeechManager();
    
    // 声明菜单
    void show_menu();

    // 属性初始化
    void initSystem();

    // 创建12名选手
    void createSpeaker();

    // 声明退出系统功能
    void exitSystem();

    // 声明比赛流程控制函数
    // 将 存放 12名 选手的容器传入该函数
    void contestControl();

    // 开始正式比赛
    void startContest(vector&lt;Speaker&gt;&amp; vSpeaker);

    // 抽签
    void randomDraw(vector&lt;Speaker&gt;&amp; vSpeaker);

    // 展示比赛结果
    void showContestResult(vector&lt;Speaker&gt;&amp; vSpeaker);

    // 将前三强写入文件中
    void writeTofile();

    // 查看往届记录
    void readRecord();

    // 清空比赛记录
    void clearRecord();

    // 声明析构函数
    ~SpeechManager();

    // 存放比赛选手容器
    // 存放第一轮比赛的12名选手的容器
    vector&lt;Speaker&gt; v1Speaker;

    // 记录比赛的进行到了第几轮
    int m_index;
&#125;;
</code></pre>
<h4 id="speechManager-cpp"><a href="#speechManager-cpp" class="headerlink" title="speechManager.cpp"></a><strong>speechManager.cpp</strong></h4><pre><code>#include&quot;speechManager.h&quot;
#include&lt;iostream&gt;
using namespace std;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
#include&lt;numeric&gt;
#include&quot;myCompare.h&quot;
#include&lt;fstream&gt;

SpeechManager::SpeechManager() &#123;
    // 初始化该系统的属性
    this-&gt;initSystem();

    // 创建12名选手
    this-&gt;createSpeaker();
&#125;

void SpeechManager::show_menu() &#123;
    cout &lt;&lt; &quot;*****************************************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;************ 欢迎参加演讲比赛 ***********&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;************ 1.开始演讲比赛 *************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;************ 2.查看往届记录 *************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;************ 3.清空比赛记录 *************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;************ 0.退出比赛程序 *************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*****************************************&quot; &lt;&lt; endl;
&#125;

void SpeechManager::initSystem() &#123;
    this-&gt;v1Speaker.clear();
    this-&gt;m_index = 0; // 初始化进行第几轮比赛
&#125;

// 创建12名选手
void SpeechManager::createSpeaker() &#123;
    string id_seed = &quot;ABCDEFGHIJKL&quot;;
    // 给选手分配id，并设置选手的初始成绩均为0
    for (int i = 0; i &lt; id_seed.size(); i++)
    &#123;
        Speaker speaker;
        speaker.m_id = id_seed[i];
        for (int j = 0; j &lt; 2; j++) // 将选手的两轮得分都设置为0
        &#123;
            speaker.m_score[j] = 0.0;
        &#125;

        // 然后将创建的每一个选手放入容器 v1Speaker
        v1Speaker.push_back(speaker);
    &#125;
&#125;

void SpeechManager::randomDraw(vector&lt;Speaker&gt;&amp; vSpeaker) &#123;
    random_shuffle(vSpeaker.begin(), vSpeaker.end()); // 该函数可以将容器内的元素打乱顺序，起到了抽签的效果
    // 显示抽签结果
    cout &lt;&lt; &quot;第 &quot;&lt;&lt; this-&gt;m_index &lt;&lt; &quot; 轮比赛抽签，显示抽签结果如下：&quot; &lt;&lt; endl;
    for (vector&lt;Speaker&gt;::iterator it = vSpeaker.begin(); it != vSpeaker.end(); it++)
    &#123;
        cout &lt;&lt; (*it).m_id &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

// 开始正式比赛
void SpeechManager::startContest(vector&lt;Speaker&gt;&amp; vSpeaker) &#123;
    deque&lt;double&gt; scoreDeque; // 记录某个选手的分数容器
    double score; // 记录选手得分的变量
    double avg; // 记录选手的平均分

    cout &lt;&lt; &quot;--------------开始第 &quot; &lt;&lt; this-&gt;m_index &lt;&lt; &quot; 轮比赛----------------&quot; &lt;&lt; endl;

    for (vector&lt;Speaker&gt;::iterator it = vSpeaker.begin(); it != vSpeaker.end(); it++)
    &#123;
        // 给容器中的每一名选手打分，共有十名评委
        for (int i = 0; i &lt; 10; i++)
        &#123;    
            score = (rand() % 400 + 600) / 10.0f;
            // cout &lt;&lt; score &lt;&lt; &quot; &quot;;
            scoreDeque.push_back(score);
        &#125;
        // cout &lt;&lt; endl;

        // 去除最高分和最低分
        sort(scoreDeque.begin(), scoreDeque.end());
        scoreDeque.pop_front();
        scoreDeque.pop_back();

        // 将剩余的八个分数累加求平均分
        avg = accumulate(scoreDeque.begin(), scoreDeque.end(), 0.0f) / (double)scoreDeque.size();
        // 将平均分放到 vector&lt;Speaker&gt; 容器中
        (*it).m_score[this-&gt;m_index - 1] = avg;
    &#125;
&#125;

void SpeechManager::showContestResult(vector&lt;Speaker&gt;&amp; vSpeaker) &#123;

    if (this-&gt;m_index == 1)
    &#123;    
        // 按照成绩进行排序
        sort(vSpeaker.begin(), vSpeaker.end(), MyCompare0());
        // 第一轮比赛结束，前六名晋级，排好序以后截取前六名选手即可
        cout &lt;&lt; &quot;-------------- 六强名单如下：----------------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;选手编号&quot; &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;成绩&quot; &lt;&lt; endl;
        vSpeaker.resize(6);
        // 公式晋级的选手
        for (vector&lt;Speaker&gt;::iterator it = vSpeaker.begin(); it != vSpeaker.end(); it++)
        &#123;
            cout &lt;&lt; &quot;   &quot; &lt;&lt; (*it).m_id &lt;&lt; &quot;\t\t&quot; &lt;&lt; (*it).m_score[this-&gt;m_index - 1] &lt;&lt; endl;
        &#125;
        cout &lt;&lt; endl;
    &#125;
    else
    &#123;
        sort(vSpeaker.begin(), vSpeaker.end(), MyCompare1());
        // 第二轮比赛结束，得到前三名
        cout &lt;&lt; &quot;-------------- 三强名单如下：----------------&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;选手编号&quot; &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;成绩&quot; &lt;&lt; endl;
        vSpeaker.resize(3);
        for (vector&lt;Speaker&gt;::iterator it = vSpeaker.begin(); it != vSpeaker.end(); it++)
        &#123;
            cout &lt;&lt; &quot;   &quot; &lt;&lt; (*it).m_id &lt;&lt; &quot;\t\t&quot; &lt;&lt; (*it).m_score[this-&gt;m_index - 1] &lt;&lt; endl;
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;

// 将前三强写入文件中
void SpeechManager::writeTofile() &#123;
    ofstream ofs;
    ofs.open(&quot;record.csv&quot;, ios::out | ios::app);
    for (vector&lt;Speaker&gt;::iterator it = v1Speaker.begin(); it != v1Speaker.end(); it++)
    &#123;
        ofs &lt;&lt; (*it).m_id &lt;&lt; &quot;,&quot; &lt;&lt; (*it).m_score[0] &lt;&lt; &quot;,&quot; &lt;&lt; (*it).m_score[1] &lt;&lt; endl;
    &#125;
    ofs &lt;&lt; &quot;============================&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;本届演讲比赛结束&quot; &lt;&lt; endl;
    ofs.close();
&#125;

// 比赛控制流程
void SpeechManager::contestControl() &#123;
    // 第一轮比赛
    this-&gt;m_index = 1;
    
    // 1.抽签
    randomDraw(v1Speaker);

    // 2.比赛开始
    startContest(v1Speaker);

    // 3.显示晋级结果,第一轮比赛以后，前六名选手进入下一轮比赛
    showContestResult(v1Speaker);

    // 第二轮比赛
    this-&gt;m_index = 2;
    // 1.抽签
    randomDraw(v1Speaker);

    // 2.比赛
    startContest(v1Speaker);

    // 3.显示决赛结果
    showContestResult(v1Speaker);

    // 4.将比赛结果录入文件
    writeTofile();

    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

// 查看往届记录
void SpeechManager::readRecord() &#123;
    ifstream ifs;
    ifs.open(&quot;record.csv&quot;, ios::in);

    // 判断文件是否存在
    if (!ifs.is_open())
    &#123;
        cout &lt;&lt; &quot;文件不存在，读取失败&quot; &lt;&lt; endl;
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
        return;
    &#125;

    char ch;
    ifs &gt;&gt; ch;
    // 判断文件存在，但，是否为空
    if (ifs.eof()) // ifstream.eof() 读到文件结束符时返回true
    &#123;
        cout &lt;&lt; &quot;文件存在，但为空&quot; &lt;&lt; endl;
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
        return;
    &#125;

    ifs.putback(ch); //将上面读取的ch放回来

    string data;
    while (getline(ifs, data))
    &#123;
        cout &lt;&lt; data &lt;&lt; endl;
    &#125;

    ifs.close();

    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

// 清空比赛记录
void SpeechManager::clearRecord() &#123;
    ofstream ofs;
    ofs.open(&quot;record.csv&quot;, ios::trunc);
    ofs.close();

    this-&gt;initSystem();

    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

void SpeechManager::exitSystem() &#123;
    cout &lt;&lt; &quot;系统退出，欢迎下次使用&quot; &lt;&lt; endl;
    exit(0);
&#125;

SpeechManager::~SpeechManager() &#123;

&#125;
</code></pre>
<h4 id="主程序-1"><a href="#主程序-1" class="headerlink" title="主程序"></a><strong>主程序</strong></h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&quot;speechManager.h&quot;
#include&lt;ctime&gt;

int main() &#123;
    srand((unsigned int)time(NULL));
    // 系统管理对象
    SpeechManager sm;
    int choice; // 记录用户的选择

    while (true)
    &#123;
        // 系统管理对象
        SpeechManager sm;
        sm.show_menu();

        cout &lt;&lt; &quot;请输入功能选项：&quot;;
        cin &gt;&gt; choice;

        switch (choice)
        &#123;
        case 1: // 开始演讲比赛
            sm.contestControl();
            break;
        case 2: // 查看往届记录
            sm.readRecord();
            break;
        case 3: // 清空比赛记录
            sm.clearRecord();
            break;
        case 0: // 退出比赛程序
            sm.exitSystem();
            break;
        default:
            cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            break;
        &#125;
    &#125;

    system(&quot;pause&quot;); // 按任意键继续
    return 0;
&#125;
</code></pre>
<h2 id="机房预约系统"><a href="#机房预约系统" class="headerlink" title="机房预约系统"></a>机房预约系统</h2><h4 id="机房预约系统主程序-cpp"><a href="#机房预约系统主程序-cpp" class="headerlink" title="机房预约系统主程序.cpp"></a>机房预约系统主程序.cpp</h4><pre><code>#include&lt;iostream&gt;
using namespace std;
#include&quot;appointmentManagerPlatform.h&quot;
#include&quot;globalFile.h&quot;

int main() &#123;
    AppointmentManagerPlatform amp;

    int identity_Choice; // 记录用户的身份选择

    while (true)
    &#123;
        amp.identity_choice_menu(); // 显示身份选择菜单
        cin &gt;&gt; identity_Choice;

        switch (identity_Choice)
        &#123;
        case 1: // 学生代表
            amp.login(STUDENT_FILE, 1);
            break;
        case 2: // 教师
            amp.login(TEACHER_FILE, 2);
            break;
        case 3: // 系统管理员
            amp.login(ADMIN_FILE, 3);
            break;
        case 0: // 系统退出
            cout &lt;&lt; &quot;系统退出，欢迎下次使用&quot; &lt;&lt; endl;
            return 0;
            break;
        default:
            cout &lt;&lt; &quot;您的输入有误，请重新输入&quot; &lt;&lt; endl;
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="appointmentManagerPlatform-h"><a href="#appointmentManagerPlatform-h" class="headerlink" title="appointmentManagerPlatform.h"></a>appointmentManagerPlatform.h</h4><pre><code>#pragma once
#include&lt;string&gt;
#include&quot;globalFile.h&quot;
using namespace std;
#include&quot;identity.h&quot;
#include&quot;student.h&quot;
#include&quot;teacher.h&quot;

class AppointmentManagerPlatform &#123;
public:
// 成员属性

// 成员函数
    // 登陆前的身份选择菜单
    void identity_choice_menu();

    // 登录，并验证身份
    void login(string file_path, int identity_type);

    // 管理员子系统
    void into_admin_system(Identity* admin);

    // 学生子系统
    void into_student_system(Identity* student);

    // 老师子系统
    void into_teacher_system(Teacher* teacher);
&#125;;
</code></pre>
<h4 id="appointmentManagerPlatform-cpp"><a href="#appointmentManagerPlatform-cpp" class="headerlink" title="appointmentManagerPlatform.cpp"></a>appointmentManagerPlatform.cpp</h4><pre><code>#include&quot;appointmentManagerPlatform.h&quot;
#include&lt;iostream&gt;
using namespace std;
#include&lt;fstream&gt;
#include&quot;identity.h&quot;
#include&quot;student.h&quot;
#include&quot;teacher.h&quot;
#include&quot;administrator.h&quot;

// 登陆前的身份选择菜单
void AppointmentManagerPlatform::identity_choice_menu() &#123;
    cout &lt;&lt; &quot;================== 欢迎来到机房预约系统 ==================&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t---------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                         |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|       1.学生代表        |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                         |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|       2.教师            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                         |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|       3.系统管理员      |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                         |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|       0.退出            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                         |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t---------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;请输入您的身份：&quot;;
&#125;

// 登录验证
void AppointmentManagerPlatform::login(string file_path, int identity_type) &#123;
    ifstream ifs;
    ifs.open(file_path, ios::in); // 只读方式打开文件
    if (!ifs.is_open())
    &#123;
        cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;
        ifs.close(); // 关闭文件流
        return;
    &#125;
    else
    &#123;    
        string id;
        string name;
        string pwd;

        string fid; // 从文件中读取的数据
        string fname;
        string fpwd;

        // 文件存在，进行身份验证
        if (identity_type == 1)
        &#123;
            cout &lt;&lt; &quot;请输入学生学号：&quot;; cin &gt;&gt; id;
            cout &lt;&lt; &quot;请输入学生姓名：&quot;; cin &gt;&gt; name;
            cout &lt;&lt; &quot;请输入登录密码：&quot;; cin &gt;&gt; pwd;

            // 进行学生身份验证
            while (ifs &gt;&gt; fid &amp;&amp; ifs &gt;&gt; fname &amp;&amp; ifs &gt;&gt; fpwd)
            &#123;
                //cout &lt;&lt; fid &lt;&lt; endl;
                //cout &lt;&lt; fname &lt;&lt; endl;
                //cout &lt;&lt; fpwd &lt;&lt; endl; 要将文本文件的编码格式改为 ansi，否则会读出乱码
                if (fid == id &amp;&amp; fname == name &amp;&amp; fpwd == pwd) &#123;
                    cout &lt;&lt; &quot;身份验证成功，欢迎使用&quot; &lt;&lt; endl;
                    ifs.close();
                    system(&quot;pause&quot;);
                    system(&quot;cls&quot;);

                    // 进入学生子系统页面
                    Identity* student = new Student(id, name, pwd);
                    into_student_system(student);
                    delete student;
                    return;
                &#125;
            &#125;
        &#125;
        else if (identity_type == 2)
        &#123;
            cout &lt;&lt; &quot;请输入教师编号：&quot;; cin &gt;&gt; id;
            cout &lt;&lt; &quot;请输入教师姓名：&quot;; cin &gt;&gt; name;
            cout &lt;&lt; &quot;请输入登录密码：&quot;; cin &gt;&gt; pwd;
        
            // 进行教师身份验证
            while (ifs &gt;&gt; fid &amp;&amp; ifs &gt;&gt; fname &amp;&amp; ifs &gt;&gt; fpwd)
            &#123;
                if (fid == id &amp;&amp; fname == name &amp;&amp; fpwd == pwd) &#123;
                    cout &lt;&lt; &quot;身份验证成功，欢迎使用&quot; &lt;&lt; endl;
                    ifs.close();
                    system(&quot;pause&quot;);
                    system(&quot;cls&quot;);

                    // 进入教师子系统页面
                    Teacher* teacher = new Teacher(id, name, pwd);
                    into_teacher_system(teacher);
                    delete teacher;
                    return;
                &#125;
            &#125;
        &#125;
        else if (identity_type == 3)
        &#123;
            cout &lt;&lt; &quot;请输入管理员编号：&quot;; cin &gt;&gt; id;
            cout &lt;&lt; &quot;请输入管理员姓名：&quot;; cin &gt;&gt; name;
            cout &lt;&lt; &quot;请输入登录密码：&quot;; cin &gt;&gt; pwd;
        
            // 进行管理员身份验证
            while (ifs &gt;&gt; fid &amp;&amp; ifs &gt;&gt; fname &amp;&amp; ifs &gt;&gt; fpwd)
            &#123;
                if (fid == id &amp;&amp; fname == name &amp;&amp; fpwd == pwd) &#123;
                    cout &lt;&lt; &quot;身份验证成功，欢迎使用&quot; &lt;&lt; endl;
                    ifs.close();
                    system(&quot;pause&quot;);
                    system(&quot;cls&quot;);
                    
                    // 进入管理员子系统
                    Identity* admin = new Administrator(id, name, pwd);
                    into_admin_system(admin);
                    delete admin;
                    return;
                &#125;
            &#125;

        &#125;
        cout &lt;&lt; &quot;身份验证失败，请重新登录&quot; &lt;&lt; endl;
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
        ifs.close();
    &#125;
&#125;

// 管理员子系统
void AppointmentManagerPlatform::into_admin_system(Identity* admin) &#123;
    Administrator* administrator = (Administrator*)admin;
    int choice;

    while (true)
    &#123;
        // 管理员子系统的界面
        administrator-&gt;sub_menu();
        cin &gt;&gt; choice;

        switch (choice)
        &#123;
        case 1: // 添加用户
            administrator-&gt;add_user();
            break;
        case 2: // 查看用户
            administrator-&gt;check_user();
            break;
        case 3: // 查看机房
            administrator-&gt;check_machineRoom();
            break;
        case 4: // 清空预约
            administrator-&gt;clean_appointmentRecord();
            break;
        case 0: // 注销登录
            cout &lt;&lt; &quot;退出登录，欢迎下次使用&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            return;
        default:
            cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            break;
        &#125;
    &#125;
&#125;

// 学生系统
void AppointmentManagerPlatform::into_student_system(Identity* stu) &#123;
    Student* student = (Student*)stu;

    int choice;
    while (true)
    &#123;
        student-&gt;sub_menu();
        cin &gt;&gt; choice;
        switch (choice)
        &#123;
        case 1: // 申请预约
            student-&gt;apply_appointment();
            break;
        case 2: // 查看我的预约
            student-&gt;check_appointment();
            break;
        case 3: // 查看所有预约
            student-&gt;check_all_appointment();
            break;
        case 4: // 取消预约
            student-&gt;cancel_appointment();
            break;
        case 0: // 注销登录
            cout &lt;&lt; &quot;退出登录，欢迎下次使用&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            return;
        default:
            cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            break;
        &#125;

    &#125;
&#125;

// 老师子系统
void AppointmentManagerPlatform::into_teacher_system(Teacher* teacher) &#123;
    int choice;


    while (true)
    &#123;
        teacher-&gt;sub_menu();
        cin &gt;&gt; choice;
        
        switch (choice)
        &#123;
        case 1: // 查看所有预约
            teacher-&gt;check_all_appointment();
            break;
        case 2: // 审核预约
            teacher-&gt;review_appointment();
            break;
        case 0: // 注销登录
            cout &lt;&lt; &quot;退出登录，欢迎下次使用&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            return;
        default:
            cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;
            system(&quot;pause&quot;);
            system(&quot;cls&quot;);
            break;
        &#125;

    &#125;
&#125;
</code></pre>
<h4 id="administrator-h"><a href="#administrator-h" class="headerlink" title="administrator.h"></a>administrator.h</h4><pre><code>#pragma once
#include&quot;identity.h&quot;
#include&lt;fstream&gt;
#include&lt;iostream&gt;
#include&quot;globalFile.h&quot;

class Administrator :public Identity &#123;
public:
    // 成员属性
    string Administrator_id;

    // 成员函数
    Administrator(); // 默认构造函数

    Administrator(string id, string name, string pwd); // 有参构造

    void sub_menu(); // 管理员子菜单

    void add_user(); // 添加用户

    void check_user(); // 查看用户

    void check_machineRoom(); // 查看机房

    void clean_appointmentRecord(); // 清空预约记录
&#125;;
</code></pre>
<h4 id="administrator-cpp"><a href="#administrator-cpp" class="headerlink" title="administrator.cpp"></a>administrator.cpp</h4><pre><code>#include&quot;administrator.h&quot;

Administrator::Administrator() &#123; // 默认构造函数

&#125;

Administrator::Administrator(string id, string name, string pwd) &#123; // 有参构造
    this-&gt;Administrator_id = id;
    this-&gt;m_name = name;
    this-&gt;m_pwd = pwd;
&#125;

void Administrator::sub_menu() &#123; // 管理员子菜单
    cout &lt;&lt; &quot;欢迎管理员：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;使用&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t-----------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           1.添加用户            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           2.查看用户            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           3.查看机房            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           4.清空预约            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           0.注销登录            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t-----------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;请输入您要执行的功能：&quot;;
&#125;

void Administrator::add_user() &#123; // 添加用户
    cout &lt;&lt; &quot;1.学生&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2.教师&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;请输入添加用户的类型：&quot;;

    int choice;
    cin &gt;&gt; choice; // 记录要添加的用户的类型

    string id;
    string name;
    string pwd;

    fstream fs;
    string data;

    string fid;
    string fname;
    string fpwd;

    if (choice == 1)
    &#123;
        // 打开学生文件
        fs.open(STUDENT_FILE, ios::in);

        cout &lt;&lt; &quot;请输入新增学生的学号：&quot;; cin &gt;&gt; id;
        cout &lt;&lt; &quot;请输入新增学生的姓名：&quot;; cin &gt;&gt; name;
        cout &lt;&lt; &quot;请输入新增学生的密码：&quot;; cin &gt;&gt; pwd;

        // 查重
        while (fs &gt;&gt; fid &amp;&amp; fs &gt;&gt; fname &amp;&amp; fs &gt;&gt; fpwd) &#123;
            if (fid == id)
            &#123;
                // 说明文件中已经存在该用户，则拒绝添加该用户
                cout &lt;&lt; &quot;该用户已经存在，无需添加&quot; &lt;&lt; endl;
                fs.close();
                system(&quot;pause&quot;);
                system(&quot;cls&quot;);
                return;
            &#125;
        &#125;
        fs.close();

        // 在fstream进行读写操作时要将读和写分开写，读写之前分别打开和关闭文件
        fs.open(STUDENT_FILE, ios::app);
        fs &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; pwd &lt;&lt; endl;
        fs.close();
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
    &#125;
    else if (choice == 2)
    &#123;
        // 打开教师文件
        fs.open(TEACHER_FILE, ios::in);

        cout &lt;&lt; &quot;请输入新增教师的编号：&quot;; cin &gt;&gt; id;
        cout &lt;&lt; &quot;请输入新增教师的姓名：&quot;; cin &gt;&gt; name;
        cout &lt;&lt; &quot;请输入新增教师的密码：&quot;; cin &gt;&gt; pwd;

        // 查重
        while (fs &gt;&gt; fid &amp;&amp; fs &gt;&gt; fname &amp;&amp; fs &gt;&gt; fpwd) &#123;
            if (fid == id)
            &#123;
                // 说明文件中已经存在该用户，则拒绝添加该用户
                cout &lt;&lt; &quot;该用户已经存在，无需添加&quot; &lt;&lt; endl;
                fs.close();
                system(&quot;pause&quot;);
                system(&quot;cls&quot;);
                return;
            &#125;
        &#125;
        fs.close();

        fs.open(TEACHER_FILE, ios::app);
        fs &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; pwd &lt;&lt; endl;
        fs.close();
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
    &#125;
&#125;

void Administrator::check_user() &#123; // 查看用户
    cout &lt;&lt; &quot;1.学生&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2.教师&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;请输入要查看的用户类型：&quot;;

    int choice;
    cin &gt;&gt; choice;

    ifstream ifs;
    string data;

    if (choice == 1)
    &#123;
        ifs.open(STUDENT_FILE, ios::in);
        while (getline(ifs, data))
        &#123;
            cout &lt;&lt; data &lt;&lt; endl;
        &#125;

    &#125;
    else if (choice == 2)
    &#123;
        ifs.open(TEACHER_FILE, ios::in);
        while (getline(ifs, data))
        &#123;
            cout &lt;&lt; data &lt;&lt; endl;
        &#125;
    &#125;

    ifs.close();
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

void Administrator::check_machineRoom() &#123; // 查看机房
    ifstream ifs;
    ifs.open(MACHINE_ROOM_FILE, ios::in);
    
    cout &lt;&lt; &quot;机房状态如下：&quot; &lt;&lt; endl;

    string data;
    while (getline(ifs, data))
    &#123;
        cout &lt;&lt; data &lt;&lt; endl;
    &#125;
    ifs.close();
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

void Administrator::clean_appointmentRecord() &#123; // 清空预约记录
    ofstream ofs(APPOINTMENT_FILE, ios::trunc);
    ofs.close();
    cout &lt;&lt; &quot;清空预约记录成功&quot; &lt;&lt; endl;
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;
</code></pre>
<h4 id="student-h"><a href="#student-h" class="headerlink" title="student.h"></a>student.h</h4><pre><code>#pragma once
#include&quot;identity.h&quot;
#include&quot;globalFile.h&quot;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;vector&gt;

class Student :public Identity &#123;
public:
    // 成员属性
    string student_id; // 学号

    // 成员函数
    Student(); // 默认无参构造

    Student(string id, string name, string pwd); // 有参构造：学号、姓名、密码

    void sub_menu(); // 实现抽象类的子菜单函数

    void apply_appointment(); // 申请预约

    void check_appointment(); // 查看预约

    void check_all_appointment(); // 查看所有人的预约

    void cancel_appointment(); // 取消预约

    bool test_appointment(int day, int interval, int roomId); // 检验该时间是否可以预约机房

&#125;;
</code></pre>
<h4 id="student-cpp"><a href="#student-cpp" class="headerlink" title="student.cpp"></a>student.cpp</h4><pre><code>#include&quot;student.h&quot;
using namespace std;
#include&lt;iostream&gt;

Student::Student() &#123; // 默认无参构造

&#125; 

Student::Student(string id, string name, string pwd) &#123; // 有参构造：学号、姓名、密码
    this-&gt;student_id = id;
    this-&gt;m_name = name;
    this-&gt;m_pwd = pwd;
&#125;

void Student::sub_menu() &#123; // 实现抽象类的子菜单函数
    cout &lt;&lt; &quot;欢迎学生代表：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;使用&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t-----------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           1.申请预约            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           2.查看我的预约        |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           3.查看所有预约        |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           4.取消预约            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           0.注销登录            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t-----------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;请输入您要执行的功能：&quot;;
&#125; 

void Student::apply_appointment() &#123; // 申请预约

    // 确定周几
    int day;
    while (true)
    &#123;
        cout &lt;&lt; &quot;请输入预约时间:&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;1.周一&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;2.周二&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;3.周三&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;4.周四&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;5.周五&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;您要预约的周几？&quot;;
        cin &gt;&gt; day;
        if (day &gt;= 1 &amp;&amp; day &lt;= 5) &#123;
            break;
        &#125;
        cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;
    &#125;

    // 确定时间段
    int interval;
    while (true)
    &#123;
        cout &lt;&lt; &quot;请选择时间段：&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;1.上午&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;2.下午&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;您要预约的时间段是：&quot;;
        cin &gt;&gt; interval;
        if (interval &gt;= 1 &amp;&amp; interval &lt;= 2)
        &#123;
            break;
        &#125;
        cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl;
    &#125;

    // 确定预约的机房
    int roodId;
    cout &lt;&lt; &quot;以下是机房信息:&quot; &lt;&lt; endl;
    ifstream ifs(MACHINE_ROOM_FILE, ios::in);
    string fid;
    string room_capacity;
    while (ifs &gt;&gt; fid &amp;&amp; ifs &gt;&gt; room_capacity) &#123;
        cout &lt;&lt; fid &lt;&lt; &quot;号机房容量为：&quot; &lt;&lt; room_capacity &lt;&lt; endl;
    &#125;
    ifs.close();
    cout &lt;&lt; &quot;您要选择的机房是：&quot;;
    cin &gt;&gt; roodId;

    // 检查预约是否重复
    // 若机房可预约，则返回 true,否则返回false
    bool flag;
    flag = test_appointment(day, interval, roodId);
    if (flag)
    &#123;
        cout &lt;&lt; &quot;预约成功，待教师审核&quot; &lt;&lt; endl;
        // 将预约信息写入预约文件
        ofstream ofs(APPOINTMENT_FILE, ios::app);
        ofs &lt;&lt; &quot;预约日期：&quot; &lt;&lt; day &lt;&lt; &quot; &quot;;
        ofs &lt;&lt; &quot;预约时间：&quot; &lt;&lt; interval &lt;&lt; &quot; &quot;;
        ofs &lt;&lt; &quot;预约机房id：&quot; &lt;&lt; roodId &lt;&lt; &quot; &quot;;
        ofs &lt;&lt; &quot;学生学号：&quot; &lt;&lt; this-&gt;student_id &lt;&lt; &quot; &quot;;
        ofs &lt;&lt; &quot;学生姓名：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot; &quot;;
        ofs &lt;&lt; &quot;机房状态：&quot; &lt;&lt; &quot;待审核&quot; &lt;&lt; endl;
        ofs.close();
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;预约失败，可以查看预约记录，重新预约&quot; &lt;&lt; endl;
    &#125;

    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

void Student::check_appointment() &#123; // 查看我的预约
    string fday;
    string finterval;
    string froomId;
    string stuId;
    string stuName;
    string status;

    bool flag = false;

    string strId = &quot;学生学号：&quot;;
    strId += this-&gt;student_id;

    ifstream ifs(APPOINTMENT_FILE, ios::in);
    cout &lt;&lt; &quot;您的预约记录如下：&quot; &lt;&lt; endl;
    while (ifs &gt;&gt; fday &amp;&amp; ifs &gt;&gt; finterval &amp;&amp; ifs &gt;&gt; froomId &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; status)
    &#123;
        if (stuId == strId)
        &#123;
            cout &lt;&lt; fday &lt;&lt; &quot; &quot; &lt;&lt; finterval &lt;&lt; &quot; &quot; &lt;&lt; froomId &lt;&lt; &quot; &quot; &lt;&lt; status &lt;&lt; endl;
            flag = true;
        &#125;
    &#125;

    if (!flag)
    &#123;
        cout &lt;&lt; &quot;您的预约记录为空！&quot; &lt;&lt; endl;
    &#125;

    ifs.close();
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125; 

void Student::check_all_appointment() &#123; // 查看所有人的预约
    cout &lt;&lt; &quot;所有预约记录如下：&quot; &lt;&lt; endl;

    string fday;
    string finterval;
    string froomId;
    string stuId;
    string stuName;
    string status;

    ifstream ifs(APPOINTMENT_FILE, ios::in);

    char ch; // 用于读取文件的第一个字符
    ifs &gt;&gt; ch;
    if (ifs.eof())
    &#123;
        cout &lt;&lt; &quot;当前预约记录为空&quot; &lt;&lt; endl;
        ifs.close();
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
        return;
    &#125;

    ifs.putback(ch); //将上面读取的ch放回来

    while (ifs &gt;&gt; fday &amp;&amp; ifs &gt;&gt; finterval &amp;&amp; ifs &gt;&gt; froomId &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; status)
    &#123;
        cout &lt;&lt; fday &lt;&lt; &quot; &quot; &lt;&lt; finterval &lt;&lt; &quot; &quot; &lt;&lt; froomId &lt;&lt; &quot; &quot; &lt;&lt; status &lt;&lt; endl;
    &#125;

    ifs.close();
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125; 

void Student::cancel_appointment() &#123; // 取消预约
    // 也就是删除我的某条预约记录
    map&lt;int, string&gt; map_appointment;
    string appointment_data;
    int index = 0;

    ifstream ifs(APPOINTMENT_FILE, ios::in);
    while (getline(ifs, appointment_data))
    &#123;
        index++;
        map_appointment.insert(make_pair(index, appointment_data));
    &#125;

    ifs.close();

    string strName = &quot;学生姓名：&quot;;
    strName += this-&gt;m_name;
    int i = -1;
    map&lt;int, string&gt; map_this_stu; // 记录了一位同学的预约记录
    vector&lt;int&gt; erase_appointment_index;

    for (map&lt;int, string&gt;::iterator it = map_appointment.begin(); it != map_appointment.end(); it++)
    &#123;
        i = (*it).second.find(strName, 0);
        if (i != -1)
        &#123;
            // 说明找到了该同学的预约记录
            // 将该条记录写入新的容器，此容器只记录了该同学的预约记录
            map_this_stu.insert(make_pair((*it).first, (*it).second));
            // 同时将大的预约容器中关于该同学的记录删除，以便之后的重新插入
            erase_appointment_index.push_back((*it).first);
        &#125;
        i = -1; // 将 i 再次设置为 0
    &#125;

    // 在大容器 map_appointment 中删除该同学的预约记录
    for (vector&lt;int&gt;::iterator it = erase_appointment_index.begin(); it != erase_appointment_index.end(); it++)
    &#123;
        map_appointment.erase((*it));
    &#125;

    for (map&lt;int, string&gt;::iterator it = map_this_stu.begin(); it != map_this_stu.end(); it++)
    &#123;
        cout &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;请选择你要删除的预约：&quot;;
    int choice; cin &gt;&gt; choice;
    map_this_stu.erase(choice);

    // 将 map_this_stu 容器中的预约数据 加入 map_appointment
    for (map&lt;int, string&gt;::iterator it = map_this_stu.begin(); it != map_this_stu.end(); it++)
    &#123;
        map_appointment.insert(make_pair((*it).first, (*it).second));
    &#125;

    // 将map_appointment写入文件
    ofstream ofs(APPOINTMENT_FILE, ios::out);
    for (map&lt;int, string&gt;::iterator it = map_appointment.begin(); it != map_appointment.end(); it++)
    &#123;
        ofs &lt;&lt; (*it).second &lt;&lt; endl;
    &#125;
    ofs.close();

    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

// 检验机房是否可以预约
bool Student::test_appointment(int day, int interval, int roomId) &#123;
    char ch;
    
    ch = day + &#39;0&#39;;  // int -&gt; char
    string strDay = &quot;预约日期：&quot;;
    strDay += ch; // char 与 字符串拼接

    ch = interval + &#39;0&#39;;
    string strInterval = &quot;预约时间：&quot;;
    strInterval += ch;

    ch = roomId + &#39;0&#39;;
    string strRoomId = &quot;预约机房id：&quot;;
    strRoomId += ch;

    string fday;
    string finterval;
    string froomId;
    string stuId;
    string stuName;
    string status;

    ifstream ifs(APPOINTMENT_FILE, ios::in);
    while (ifs &gt;&gt; fday &amp;&amp; ifs &gt;&gt; finterval &amp;&amp; ifs &gt;&gt; froomId &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; status) &#123;
        if (strDay == fday &amp;&amp; strInterval == finterval &amp;&amp; strRoomId == froomId)
        &#123;
            cout &lt;&lt; &quot;该机房已经在该该时间段预约，请重新预约&quot; &lt;&lt; endl;
            ifs.close();
            return false;
        &#125;
    &#125;
    ifs.close();
    return true;
&#125;
</code></pre>
<h4 id="teacher-h"><a href="#teacher-h" class="headerlink" title="teacher.h"></a>teacher.h</h4><pre><code>#pragma once
#include&quot;identity.h&quot;
#include&lt;fstream&gt;
#include&quot;globalFile.h&quot;
#include&lt;map&gt;

class Teacher :public Identity &#123;
public:
    // 成员属性
    string teacher_id;

    // 成员函数
    Teacher(); // 默认构造

    Teacher(string id, string name, string pwd); // 有参构造：教师编号、姓名、密码

    void sub_menu(); // 教师子菜单

    void check_all_appointment(); // 查看所有预约

    void review_appointment(); // 审核预约

&#125;;
</code></pre>
<h4 id="teacher-cpp"><a href="#teacher-cpp" class="headerlink" title="teacher.cpp"></a>teacher.cpp</h4><pre><code>#include&quot;teacher.h&quot;

Teacher::Teacher() &#123; // 默认构造

&#125; 

Teacher::Teacher(string id, string name, string pwd) &#123; // 有参构造：教师编号、姓名、密码
    this-&gt;teacher_id = id;
    this-&gt;m_name = name;
    this-&gt;m_pwd = pwd;
&#125; 

void Teacher::sub_menu() &#123; // 教师子菜单
    cout &lt;&lt; &quot;欢迎教师：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;使用&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t-----------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           1.查看所有预约        |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           2.审核预约            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|           0.注销登录            |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t|                                 |&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\t\t-----------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;请输入您要执行的功能：&quot;;
&#125; 

void Teacher::check_all_appointment() &#123; // 查看所有预约
    cout &lt;&lt; &quot;所有预约记录如下：&quot; &lt;&lt; endl;

    string fday;
    string finterval;
    string froomId;
    string stuId;
    string stuName;
    string status;

    ifstream ifs(APPOINTMENT_FILE, ios::in);

    char ch; // 用于读取文件的第一个字符
    ifs &gt;&gt; ch;
    if (ifs.eof())
    &#123;
        cout &lt;&lt; &quot;当前预约记录为空&quot; &lt;&lt; endl;
        ifs.close();
        system(&quot;pause&quot;);
        system(&quot;cls&quot;);
        return;
    &#125;

    ifs.putback(ch); //将上面读取的ch放回来

    while (ifs &gt;&gt; fday &amp;&amp; ifs &gt;&gt; finterval &amp;&amp; ifs &gt;&gt; froomId &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; status)
    &#123;
        cout &lt;&lt; fday &lt;&lt; &quot; &quot; &lt;&lt; finterval &lt;&lt; &quot; &quot; &lt;&lt; froomId &lt;&lt; &quot; &quot; &lt;&lt; status &lt;&lt; endl;
    &#125;

    ifs.close();
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;

void Teacher::review_appointment() &#123; // 审核预约
    // 预约有两种状态
    // 待审核、审核通过
    // 只显示需要审核的预约信息

    map&lt;int, string&gt; map_appointment;
    string str_appointment;
    int index = 0;

    ifstream ifs(APPOINTMENT_FILE, ios::in);
    while (getline(ifs, str_appointment))
    &#123;
        index++;
        map_appointment.insert(make_pair(index, str_appointment));
    &#125;
    ifs.close();


    for (map&lt;int, string&gt;::iterator it = map_appointment.begin(); it != map_appointment.end(); it++)
    &#123;
        cout &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;您想要审核的预约记录是：&quot;;
    int choice; cin &gt;&gt; choice;

    map&lt;int, string&gt;::iterator modifyData =  map_appointment.find(choice);
    int i = (*modifyData).second.find(&quot;待审核&quot;);
    (*modifyData).second.replace(i, 10, &quot;审核通过&quot;);

    ofstream ofs(APPOINTMENT_FILE, ios::out);

    for (map&lt;int, string&gt;::iterator it = map_appointment.begin(); it != map_appointment.end(); it++)
    &#123;
        ofs &lt;&lt; (*it).second &lt;&lt; endl;
    &#125;

    ofs.close();
    system(&quot;pause&quot;);
    system(&quot;cls&quot;);
&#125;
</code></pre>
<h4 id="globalFile-h"><a href="#globalFile-h" class="headerlink" title="globalFile.h"></a>globalFile.h</h4><pre><code>#pragma once

// 管理员文件
#define ADMIN_FILE &quot;admin.txt&quot;

// 学生文件
#define STUDENT_FILE &quot;student.txt&quot;

// 教师文件
#define TEACHER_FILE &quot;teacher.txt&quot;

// 机房信息文件
#define MACHINE_ROOM_FILE &quot;machineRoom.txt&quot;

// 预约文件
#define APPOINTMENT_FILE &quot;appointment.txt&quot;
</code></pre>
<h4 id="identity-h"><a href="#identity-h" class="headerlink" title="identity.h"></a>identity.h</h4><pre><code>#pragma once
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;


// 学生代表、教师、管理员的身份抽象基类
// 该类中只要有一个虚函数，该类就为抽象类，无法实例化对象，因此只写 .h 文件声明该基类即可
class Identity &#123;
public:
    // 成员属性
    string m_name;
    string m_pwd;

    // 成员函数
    // 子菜单，纯虚函数，实现多态，实现不同身份对应的不同子菜单
    virtual void sub_menu() = 0;
&#125;;
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ztHao</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://zhitenghao.github.io/2022/050531891.html">https://zhitenghao.github.io/2022/050531891.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ztHao</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                    <span class="chip bg-color">后端</span>
                                </a>
                            
                                <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
                                    <span class="chip bg-color">编程语言</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/050531891.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="C++初级">
                        
                        <span class="card-title">C++初级</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-05-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="post-category">
                                    编程语言
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%90%8E%E7%AB%AF/">
                        <span class="chip bg-color">后端</span>
                    </a>
                    
                    <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
                        <span class="chip bg-color">编程语言</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/030716107.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ztHao
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">ztHao</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">2.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href=https://github.com/zhitenghao class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:546863688@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=546863688" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 546863688" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
